
[19:20:24][game_application.cpp:2220]: 
== TRIGGER DOCUMENTATION ==
text - For 'desc={trigger={' use. Shows custom text
text = <text>
Supported Scopes: all

not - An inverted trigger
Supported Scopes: all

custom_tooltip - Replaces the tooltips for the enclosed triggers with a custom text
custom_tooltip = {
	text = <text used as fallback for both fails and successes>
	fail_text = <text used for fails["string"/default/none]>
	success_text = <text used for successes["string"/default/none]>
	<triggers>
}
Supported Scopes: all

if - Evaluates the triggers if the display_triggers of the limit are met
if = { limit = { <display_triggers> } <triggers> }
Supported Scopes: all

has_mission - Checks if the observation post has a specific mission
has_mission = technological_enlightenment_4
Supported Scopes: fleet

switch - Switch case for a trigger
switch = {
	trigger = pop_has_ethic
	ethic_xenophile = { <trigger> }
	ethic_xenophobe = { <trigger> }
	default = { <trigger> }
}
Supported Scopes: all

num_fleets - Checks the country's number of fleets
num_fleets < 8
Supported Scopes: country

num_ships - Checks the country/fleet's number of ships
num_ships > 39
Supported Scopes: country ship fleet

has_fleet_order - Checks if the ship/fleet has a specific fleet order. Fleet orders include: move_to_system_point_order orbit_planet_order build_orbital_station_order build_space_station_order colonize_planet_order survey_planet_order research_discovery_orde research_anomaly_order collect_data_fleet_order upgrade_design_at_starbase_fleet_order upgrade_design_at_orbitable_fleet_order return_fleet_order repair_fleet_order evade_hostiles_order follow_order land_armies_order merge_fleet_order aggressive_stance_fleet_order auto_explore_order build_megastructure_fleet_order destroy_planet_order planet_killer_weapon_windup_order planet_killer_weapon_fire_order explore_bypass_order use_bypass_order jumpdrive_order jumpdrive_windup experimental_subspace_navigation_fleet_order excavate_archaeological_site_fleet_order
has_fleet_order = survey_planet_order
Supported Scopes: ship fleet

closest_system - Finds the closest system within the given hyperlane steps and limit = { <triggers> }. If this system does not exist, it returns false. If it does exist, it is checked against the triggers outside of the limit = {}.
closest_system = {
	limit = { <triggers> }
	min_steps = 2
	max_steps = 20
	use_bypasses = yes/no (default: no)
	<triggers>
}
Supported Scopes: all

has_orbital_station - Checks if the planet has any kind of orbital station
has_orbital_station = yes
Supported Scopes: planet

else_if - Evaluates the enclosed triggers if the display_triggers of the preceding `if` or `else_if` is not met and its own display_trigger of the limit is met
if = { limit = { <display_triggers> } <triggers> }
else_if = { limit = { <display_triggers> } <triggers> }
Supported Scopes: all

is_orbiting_star - Checks if a ship is orbiting a star
Supported Scopes: ship fleet

cosmic_storm_influence_value - Returns the amount of influence on a system
Supported Scopes: galactic_object

happiness - Checks the pop group's happiness percentage
happiness < 0.5
Supported Scopes: pop pop_group

leader_years_of_service - Checks the scope leader's years of service
years_of_service > 25
Supported Scopes: leader

num_leader_traits - Checks the number of leader traits or total tiers of traits for a specific leader
num_leader_traits = {  value > 2/variable  is_councilor = <any(default)/yes(only)/no(only)> negative <any(default)/no(only)/yes(only)>  count_tiers = <yes/no(default)> contains_modifier = { string = "federation" type=<any(default)/yes(only)/no(only) # filters on whether the trait has a modifier that contains the string "string"is_subclass = <any(default)/yes(only)/no(only) }
Supported Scopes: leader

is_ruler - Checks if scoped leader is the Ruler of the Empire 
is_ruler = yes/no
Supported Scopes: leader

is_heir - Checks if scoped leader is the Heir of the Empire 
is_heir = yes/no
Supported Scopes: leader

agreement_preset - Checks if the agreement has the specified preset
agreement_preset = <preset key>
Supported Scopes: agreement

get_councilor_level - Get the level of a specific councilor 
get_councilor_level = { type = <key> }
Supported Scopes: country

faction_approval - Checks the scoped faction's approval percentage
faction_approval < 0.9
Supported Scopes: pop_faction

has_designation - Checks if the colony has a certain designation
has_designation = col_rural/<planet scope>
Supported Scopes: planet

colony_type - Checks if the colony is of a certain type
colony_type = col_rural/<planet scope>
Supported Scopes: planet

num_favors - Check amount of favors that scoped country can collect from target country:
num_favors = {
	target = <country>
	value ><= <value>/<variable>
}
Supported Scopes: country

num_ships_in_debris - Checks the number of ships of a ship size in debris
num_ships_in_debris = { ship_size = corvette value > 15 }
Supported Scopes: debris

last_building_changed - Checks if the last building queued/unqueued/built/demolished/upgraded was the specified building
last_building_changed = building_capitol
Supported Scopes: planet

empire_size - Checks the empire's size. Identical to empire_sprawl trigger.
empire_size < 20
Supported Scopes: country

empire_sprawl - Checks the empire's sprawl. Identical to empire_size trigger.
empire_sprawl < 20
Supported Scopes: country

empire_sprawl_over_cap - Checks how much the empire's sprawl is over its admin capacity
empire_sprawl_over_cap < 5
Supported Scopes: country

empire_sprawl_cap_fraction - Checks the empire's sprawl compared to its admin level
empire_sprawl_cap_fraction < 0.5
Supported Scopes: country

last_district_changed - Checks if the last district queued/unqueued/built/demolished/upgraded was the specified district
last_district_changed = district_capitol
Supported Scopes: planet

has_ring - Checks if the planet has a planetary ring
has_ring = yes
Supported Scopes: planet

is_moon - Checks if the planet is the moon of another planet
is_moon = yes
Supported Scopes: planet

opinion - Checks the country's opinion of the target country
opinion = { who = <target> value = -70/variable }
Supported Scopes: country

opinion_level - Checks the country's opinion level of the target country (with support for comparison operators)
opinion_level = { who = <target> level >= neutral }
Supported Scopes: country

envoy_opinion_change - Checks the country's opinion of the target country has been changed by envoys
envoy_opinion_change = { who = <target> value >= 25/variable }
Supported Scopes: country

ideal_planet_class - Checks if the pop group, species or country's ideal planet class is a specific class
ideal_planet_class = pc_tundra/<planet scope>
Supported Scopes: country pop pop_group species

ethos - Checks the average ethics divergence on the planet, i.e. num of pops not of the country's ethics / total num of pops
ethos < 0.4
Supported Scopes: planet

distance - Checks the ship/fleet/planet/leader/pop group/system's galaxy map distance to target in absolute units
distance = {
	source = <target>
	min_distance >= 50
	max_distance <= 120
	type=<hyperlane/euclidean>
	bypass_empire=<empire>
	min_jumps = 2
	max_jumps = 10
	same_solar_system = yes/no (default: no; this toggles whether the trigger checks galaxy map or solar system distances)
}
Supported Scopes: megastructure planet ship pop pop_group fleet galactic_object leader ambient_object starbase deposit archaeological_site first_contact

is_pirate - Checks if the country is a pirate country
is_pirate = yes
Supported Scopes: country

planet_size - Checks the planet's size
planet_size < 20
Supported Scopes: planet

gender - Checks the leader's gender
gender = female/male/indeterminable
Supported Scopes: leader

pop_has_ethic - Checks if the pop has a specific ethos
pop_has_ethic = ethic_fanatic_xenophile
Supported Scopes: pop pop_group

pop_group_has_ethic - Checks if the pop group has a specific ethos
pop_group_has_ethic = ethic_fanatic_xenophile
Supported Scopes: pop_group

pop_group_has_trait - Checks if the pop group has a specific trait
pop_group_has_trait = trait_decadent
Supported Scopes: pop_group

has_observation_outpost - Checks if the planet has an observation post
has_observation_outpost = yes
Supported Scopes: planet

starting_system - Checks if the system is the starting system for any country
starting_system = yes
Supported Scopes: galactic_object

graphical_culture - Checks if the country/ship/megastructure/species has specific graphical culture or the same graphical culture as the target.
 When used on a species this compares the culture of the species class to the target.
graphical_culture = <fungoid_01/FROM>
Supported Scopes: megastructure country ship species

is_civilian - Checks if the scoped fleet or ship is civilian (as set in ship sizes).
is_civilian = <yes/no>
Supported Scopes: ship fleet

vassals - Checks the country's number of subjects with agreement preset 'preset_vassal'
vassals > 0
Supported Scopes: country

exists - Checks if a target scope exists
exists = <target>
Supported Scopes: all

has_edict - Checks if the country has a specific edict enabled
has_edict = crystal_sonar
Supported Scopes: country

is_designable - Checks if the scoped ship design, ship or fleet (all ships) has a designable ship size.
is_designable = yes
Supported Scopes: ship fleet design ship_growth_stage

is_in_cluster - Checks if the planet/system belongs to a specific spawning cluster
is_in_cluster = resource_cluster_3
Supported Scopes: planet galactic_object

num_empires - Checks the number of regular empires in the galaxy
num_empires > 3
Supported Scopes: country

leader_class - Checks if the leader is of a specific class
leader_class = scientist
Supported Scopes: leader

leader_age - Checks the scope leader's age
leader_age > 85
Supported Scopes: leader

leader_lifespan - Checks the scope leader's lifespan
leader_lifespan > 85
Supported Scopes: leader

has_deposit - Checks if the planet has any, or a specific, deposit
has_deposit = yes
has_deposit = d_immense_engineering_deposit
Supported Scopes: planet deposit

is_same_value - Checks if the current scope and the target scope are the same thing
is_same_value = <target>
Supported Scopes: all

intel - Checks the country's Intel on the target country
intel = { who = <target> value = 70/variable }
Supported Scopes: country

has_pop_faction_flag - Checks if the pop faction has a specific flag
has_pop_faction_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop pop_group pop_faction

num_communications - Checks the country's number of established communications
num_communications > 3
Supported Scopes: country

last_changed_policy - Checks if the last policy changed by the country was a specific policy
last_changed_policy = slavery
Supported Scopes: country

is_species - Checks if the pop group/country's founder species is of a specific pre-defined species
is_species = ROBOT_POP_SPECIES_2
Supported Scopes: country pop pop_group leader species

last_increased_tech - Checks if the country's last researched technology was a specific tech
last_increased_tech = tech_gene_expressions
Supported Scopes: country

original_owner - Checks if the planet is still owned by its first colonizer
original_owner = yes
Supported Scopes: planet

subjects - Checks the country's number of subjects
subjects > 0
Supported Scopes: country

tech_unlocked_ratio - Checks the relative amount of already-researched tech between the country and target country
tech_unlocked_ratio = { who = <target> ratio = 0.4/variable }
Supported Scopes: country

can_colonize - Checks if the planet can be colonized by target country
can_colonize = { who = <target> status = yes }
Supported Scopes: planet

has_special_project - Checks if the country has a specific special project available
has_special_project = EMERGENCY_BUOY_PROJECT
Supported Scopes: country

has_completed_special_project_in_log - Checks if the country has completed a specific special project as part of an in-progress event chain
has_completed_special_project_in_log = EMERGENCY_BUOY_PROJECT
Supported Scopes: country

has_failed_special_project_in_log - Checks if the country has failed, timed out or aborted a specific special project as part of an in-progress event chain
has_failed_special_project_in_log = EMERGENCY_BUOY_PROJECT
Supported Scopes: country

is_subspecies - Checks if the pop group/country/species is a subspecies of the target species
is_subspecies = <target>
Supported Scopes: country pop pop_group leader species

is_valid - Checks to see if target scope is valid for the country/planet/army
is_valid = yes/no
Supported Scopes: planet country army

city_graphical_culture - Checks if the country has a specific graphical culture for its city image or the same graphical culture as the target.
If the target is a country, this trigger will compare its city graphical culture to the scoped country city graphical culture
city_graphical_culture = <fungoid_01/FROM>
Supported Scopes: country

check_pop_faction_parameter - Checks if one of the faction's parameters is the same as target scope
check_pop_faction_parameter = { which = <parameter> value = <target> }
Supported Scopes: pop_faction

is_robot_pop - Checks if the pop is a robot
is_robot_pop = yes
Supported Scopes: pop pop_group

is_robot_pop_group - Checks if the pop group is a robot
is_robot_pop_group = yes
Supported Scopes: pop_group

num_fallen_empires - Checks the number of fallen empires in the galaxy
num_fallen_empires > 3
Supported Scopes: country

is_preferred_weapons - Checks if the country's AI prefers weapons using this component tag
is_preferred_weapons = weapon_type_energy
Supported Scopes: country

has_access_fleet - Checks if the target country is allowed to enter the system
has_access_fleet = <target>
Supported Scopes: galactic_object

is_point_of_interest - Checks if the planet/country/ship/system/ambient object has a specific point of interest for a specific event chain for a specific country
is_point_of_interest = { id = <id> event_chain = <event_chain> owner = <target> }
Supported Scopes: planet country ship galactic_object ambient_object

terraformed_by - Checks if planet is terraformed by country.
terraformed_by = <scope>
Supported Scopes: planet

has_megastructure - Checks if a country or star has a mega structure.
has_megastructure = spy_orb_4
Supported Scopes: country galactic_object

recently_lost_war - Checks if the country recently lost a war ('recently' meaning recent enough to have a truce)
recently_lost_war = yes
Supported Scopes: country

has_research_agreement - Checks if two countries have a research agreement.
has_research_agreement = <target>
Supported Scopes: country

upgrade_days_left - Checks how many days an upgrading megastructure will take to complete its upgrade.
upgrade_days_left > 360
Supported Scopes: megastructure

has_any_megastructure - Checks if the scope has a megastructure
has_any_megastructure = yes
Supported Scopes: planet galactic_object

former_living_standard_type - Compares the former living standard type with the given one.
former_living_standard_type = living_standard_normal
Supported Scopes: pop pop_group

former_citizenship_type - Compares the former citizenship type with the given one.
former_citizenship_type = citizenship_full
Supported Scopes: pop pop_group

former_military_service_type - Compares the former military service type with the given one.
former_military_service_type = military_service_full
Supported Scopes: pop pop_group

former_slavery_type - Compares the former slavery type with the given one.
former_slavery_type = slavery_normal
Supported Scopes: pop pop_group

former_purge_type - Compares the former purge type with the given one.
former_purge_type = purge_normal
Supported Scopes: pop pop_group

former_population_control_type - Compares the former population control type with the given one.
former_population_control_type = population_control_yes
Supported Scopes: pop pop_group

former_migration_control_type - Compares the former migration control type with the given one.
former_migration_control_type = migration_control_yes
Supported Scopes: pop pop_group

inner_radius - Checks the inner radius of a solar system
inner_radius > 300
Supported Scopes: galactic_object

council_agenda_progress - Checks the progress of the current Agenda.
council_agenda_progress >= <value>
Supported Scopes: country

additional_crisis_strength - Checks the degree to which multiply_crisis_strength effect is increasing the strength of endgame crises
additional_crisis_strength > 1.4
Supported Scopes: all

is_alliance_fleet - Checks if the scoped fleet is an alliance fleet.
is_alliance_fleet = <yes/no>
Supported Scopes: fleet

has_forbidden_jobs - Check that you have forbidden job of a specific type
has_forbidden_jobs = "miner"
Supported Scopes: planet

is_researching_special_project - Checks if the country is currently researching a specific special project
is_researching_special_project = special_project_name
Supported Scopes: country leader

last_activated_relic - Checks if the specified relic was the last activated one 
last_activated_relic = <relic_key>
Supported Scopes: country

is_scope_type - Checks currently in the specified scope:
is_scope_type = fleet
valid tokens are: none, megastructure, planet, country, ship, pop, fleet, galactic_object, leader, army, ambient_object, species, design,pop_faction, war, alliance, starbase,deposit,observer, sector, astral_rift.
Supported Scopes: all

is_robotic - Check if the species in the scope is a robot species or not
is_robotic=<yes/no>
Supported Scopes: species

has_unlocked_all_traditions - Checks if the country has unlocked all traditions
has_unlocked_all_traditions = yes/no
Supported Scopes: country

has_potential_claims - Checks if the country has any potential claims they can make.
has_potential_claims = yes/no
Supported Scopes: country

is_councilor_type - Checks if the leader holds a specific Councilor type
is_councilor_type = councilor_research
Supported Scopes: leader

is_ethic_represented_on_council - Checks if any Councilor has a given ethic.
is_ethic_represented_on_council = ethic_materialist
Supported Scopes: country

last_lost_relic - Checks if the specified relic was the last lost one 
last_lost_relic = <relic_key>
Supported Scopes: country

last_received_relic - Checks if the specified relic was the last received one 
last_received_relic = <relic_key>
Supported Scopes: country

civics_count - Checks the country's number of civics
civics_count < 3
Supported Scopes: country

has_available_jobs - Check that you have available job of a specific type
has_available_jobs = "miner"
Supported Scopes: planet

free_jobs_of_type - Check how many free jobs there are of a specific jobtype or pop category on a planet
free_jobs_of_type = {
job = <jobtype>
category = <pop_category>
include_deprioritized_jobs = <yes/no>: default = no
value <comparator> <value>
}
Supported Scopes: planet

is_galactic_custodian - Checks if an empire is Custodian of the Galactic Council
is_galactic_custodian = yes/no
Supported Scopes: country

has_galactic_custodian - Checks if the Galactic Community has named a Custodian
has_galactic_custodian = yes/no
Supported Scopes: all

is_galactic_emperor - Checks if an empire is the Galactic Emperor
is_galactic_emperor = yes/no
Supported Scopes: country

has_galactic_emperor - Checks if the Galactic Emperor has taken over
has_galactic_emperor = yes/no
Supported Scopes: all

imperial_authority - Checks imperial authority.
imperial_authority >=< 40
Supported Scopes: all

has_stage_modifier - Checks if the espionage operation has a certain modifier specific for the current stage
has_stage_modifier = <modifier>
Supported Scopes: espionage_operation astral_rift

galactic_defense_force_exists - Checks if the Galactic Defense Force or Imperial Armada exists
galactic_defense_force_exists = yes/no
Supported Scopes: all

has_intel_level - Checks the country's intel level on a category for the target country
has_intel_level = { who = <target> category = economy level = 2/variable }
Supported Scopes: country

has_intel_report - Checks if the country has intel report of at least the specified level on a category for the target country
has_intel_report = { who = <target> category = economy level = 2/variable }
Supported Scopes: country

has_intel - Checks if the specified intel is available for the target country (stale intel will not return true)
has_intel = { who = <target> intel = system_low_intel }
Supported Scopes: country

has_stale_intel - Checks if the specified intel is stale for the target country (available intel will not return true)
has_stale_intel = { who = <target> intel = system_low_intel }
Supported Scopes: country

and - all inside trigger must be true
Supported Scopes: all

or - At least one entry inside the trigger must be true
Supported Scopes: all

is_star - Checks if the planet is a star
is_star = yes
Supported Scopes: planet

is_asteroid - Checks if the planet is an asteroid
is_asteroid = yes
Supported Scopes: planet

is_astral_scar - Checks if the planet is an astral scar
is_astral_scar = yes
Supported Scopes: planet

species_portrait - Checks if the species (or pop group/empire's dominant species) uses a certain portrait
species_portrait = rep13
Supported Scopes: country pop pop_group species

is_reanimated - Checks if the scoped fleet or ship is reanimated (as set in ship sizes).
is_reanimated = <yes/no>
Supported Scopes: ship fleet ship_growth_stage

is_neutral_to - Checks if the country has a neutral attitude towards target country
is_neutral_to = <target>
Supported Scopes: country

trust - Checks the country's trust of the target country
trust = { who = <target> value = 50/variable }
Supported Scopes: country

name_list_category - Checks if a specific name list is used for the a species during empire creation
Supported Scopes: dlc_recommendation

is_under_societal_enlightenment - Checks if country is under societal enlightenment
is_under_societal_enlightenment = <target>
Supported Scopes: country

is_under_open_technological_enlightenment - Checks if country is under open technological enlightenment
is_under_open_technological_enlightenment = <target>
Supported Scopes: country

is_under_stratified_technological_enlightenment - Checks if country is under stratified technological enlightenment
is_under_stratified_technological_enlightenment = <target>
Supported Scopes: country

has_pre_ftl_trade - Checks if country has pre-ftl trade
has_pre_ftl_trade = <target>
Supported Scopes: country

current_stage - Checks if the specified stage is currently active in the scoped situation.
current_stage = <stage> (name defined in situation's stages)
Supported Scopes: situation

is_leased - Checks if the scoped fleet is leased.
is_leased = <yes/no>
Supported Scopes: fleet

lease_days - Checks the number of days left before fleet lease contract is finished
lease_days < 77
Supported Scopes: fleet

has_loyalty - Checks the subject's current loyalty to its overlord.
has_loyalty >=< -50
Supported Scopes: country

has_monthly_loyalty - Checks the subject's current monthly loyalty gain/loss.
has_monthly_loyalty >=< -5
Supported Scopes: country

can_lock_be_renewed - Returns true if the Bypass Lock can be renewed
can_lock_be_renewed = yes
Supported Scopes: bypass

acquired_specimen_count - Returns the country's acquired specimens count
acquired_specimen_count > <num>
Supported Scopes: country

balance - Checks the country's energy credit balance
balance < 39
Supported Scopes: country

is_inside_storm - Checks if the system is inside any storm or a specific storm type.
is_inside_storm = yes/no/<storm_type>
Supported Scopes: galactic_object

is_on_border - Checks if the system is on a countries border
Supported Scopes: galactic_object

is_infertile - Checks if the pop group/species has any trait with infertile
is_infertile = yes/no
Supported Scopes: pop pop_group species

must_scavenge - Checks if the debris is set as "must scavenge"
must_scavenge = yes/no
Supported Scopes: debris

must_research - Checks if the debris is set as "must research"
must_research = yes/no
Supported Scopes: debris

voidworms_scaling - Checks Voidworms presence scaling in game setup
Supported Scopes: all

cutholoids_scaling - Checks Cutholoids presence scaling in game setup
Supported Scopes: all

has_picked_auto_mod_habitability - Checks if a pop has already picked an auto modded habitability trait.
has_picked_auto_mod_habitability = <yes/no>
Supported Scopes: pop_group

has_highest_technology_score - Checks if the country has the highest technology score
has_highest_technology_score = yes/no
Supported Scopes: country

is_growth_complete - Checks if the ship growth progress has maxed out.
is_growth_complete = yes / no
Supported Scopes: ship

hidden_trigger - Hides the tooltip for the triggers within
hidden_trigger = { <triggers> }
Supported Scopes: all

has_district - Checks if the planet has any, or a specific, district
has_district = yes
has_district = district_mining
Supported Scopes: planet

free_district_slots - Checks the planet's number of slots available for new constructions
free_district_slots > 2
Supported Scopes: planet

diplomacy_weight - Checks the country's diplomatic weight
diplomacy_weight > 200
Supported Scopes: country

has_owner - Checks if the planet is colonized (in planet scope) or the system has an owner (in system scope)
has_owner = yes
Supported Scopes: planet galactic_object

free_housing - Checks the planet's available housing
free_housing > 5
Supported Scopes: planet

is_ai - Checks if the country is played by the AI
is_ai = no
Supported Scopes: country

always - Sets trigger to be either always true or false
always = yes
Supported Scopes: all

has_trait - Checks if a pop group/leader/species/country's dominant species has a certain trait
has_trait = leader_trait_carefree
Supported Scopes: country pop pop_group leader species dlc_recommendation

has_ethic - Checks if a country/pop group/leader/faction has a certain ethos
has_ethic = ethic_fanatic_pacifist
Supported Scopes: country pop pop_group leader pop_faction dlc_recommendation

is_owned_by - Checks if the planet/system/army/ship is owned by the target country
is_owned_by = <target>
Supported Scopes: megastructure planet ship pop pop_group fleet galactic_object leader army pop_faction starbase deposit sector archaeological_site first_contact spy_network espionage_operation agreement situation

is_immortal - Checks if the leader is immortal (either by script effect or species characteristics)
is_immortal = yes/no
Supported Scopes: leader

is_hidden - Checks if the leader is hidden from the player
is_hidden = yes/no
Supported Scopes: leader

can_live_on_planet - Checks if the pop group or species is allowed to live on a specified planet
can_live_on_planet = from.capital_scope
Supported Scopes: pop pop_group species

days_passed - Checks the number of in-game days passed since the 2200.1.1 start
days_passed < 15
Supported Scopes: all

free_amenities - Checks the planet's available amenities
free_amenities > 5
Supported Scopes: planet

has_deficit - Checks if the country or planet has a deficit of the defined resource. Only populated planets can have deficits.
has_deficit = minerals
Supported Scopes: planet country

has_commercial_pact - Check if the country has a commercial pact with target country
has_commercial_pact = <target>
Supported Scopes: country

has_role - Checks ship design has a certain role.
has_role = gunship
Supported Scopes: design ship_growth_stage

is_being_assimilated - Checks if the pop group is being assimilated
is_being_assimilated = yes
Supported Scopes: pop pop_group

num_guaranteed_colonies - Checks the number of guaranteed colonies defined in setup
num_guaranteed_colonies > 1
Supported Scopes: all

num_owned_relics - Checks the number of relics owned by the scoped country
num_owned_relics > 1
Supported Scopes: country

has_civic_in_slot - Checks if the country has a civic in a slot 
has_civic_in_slot = { civic = civic_galactic_sovereign index = 2 }
Supported Scopes: country

has_total_civic_points - Compares the amount of total civic points.
has_total_civic_points >= <value>
Supported Scopes: country

has_unused_civic_points - Compares the amount of unused civic points.
has_unused_civic_points >= <value>
Supported Scopes: country

num_candidate_supported - Compares the number of times an election candidate was supported.
num_candidate_supported >= <value>
Supported Scopes: leader

council_agenda_progress_percent - Compares the progress (0-1) of the current Agenda.
council_agenda_progress_percent >= <value>
Supported Scopes: country

council_legitimacy - Checks current value for council legitimacy for the scoped country.
council_legitimacy >= <value>
Supported Scopes: country

has_agenda_selected - Checks if the country has a specific Council Agenda selected, or any at all
has_agenda_selected = <yes/any/no/none/type>
Supported Scopes: country

has_unlocked_council_positions - Compares the amount of unlocked council positions, typically from 'unlock_council_slots'
has_unlocked_council_positions >= <value>
Supported Scopes: country

has_branch_office - Check if the planet has a branch office owned by target country/any country/no country
has_branch_office = <target/yes/no>
Supported Scopes: planet

is_same_species - checks if the scoped object is of the same species as another object
is_same_species = <target>
Supported Scopes: country ship pop pop_group leader army species

is_criminal_syndicate - Checks if the country is a criminal syndicate
is_criminal_syndicate = yes
Supported Scopes: country

is_blocker - Checks if scoped deposit is a blocker-type
is_blocker = yes
Supported Scopes: deposit

is_same_empire - Checks if the country is the same as another, target country
is_same_empire = <target>
Supported Scopes: country

free_branch_office_building_slots - Checks the planet's number of branch office slots available for new constructions
free_branch_office_building_slots > 2
Supported Scopes: planet

branch_office_value - Checks the planet's branch officevalue
branch_office_value = { who = <target> value > 10/variable }
Supported Scopes: planet

free_jobs - Checks the number of unassigned jobs on the planet
free_jobs > 12
Supported Scopes: planet

is_planet_class - Checks if the planet is of a certain class
is_planet_class = pc_tundra/<planet scope>
Supported Scopes: planet dlc_recommendation

has_strategic_resource - Checks if the planet or astral rift has any strategic resource
has_strategic_resource = yes
Supported Scopes: planet astral_rift

is_star_class - Checks if the system/planet(star) is of a certain class
is_star_class = sc_black_hole/<system scope>
Supported Scopes: planet galactic_object

has_technology - Checks if the country has a technology (of at least a specific level)
has_technology = tech_spaceport_4
Supported Scopes: country

can_research_technology - Checks whether the current country is allowed to have the specified technology, i.e. does it fulfil the potential = { } field for that tech, and for any prereq techs that tech has.
can_research_technology = <tech key>
Supported Scopes: country

can_copy_random_tech_from - Checks whether the target country has a technology the current country can steal via copy_random_tech_from effect
can_copy_random_tech_from = {
	who = <country>
	category = computing (optional)
	area = physics (optional)
}
Supported Scopes: country

can_set_policy - Checks if the country is allowed to set its policy to a specific one using set_policy effect
can_set_policy = { policy = <key> option = <key> }
Supported Scopes: country

planet_devastation - Checks the planet's devastation
planet_devastation > 10
Supported Scopes: planet

is_pop_category - Checks if the pop group has the chosen pop category
is_pop_category = <key>
Supported Scopes: pop pop_group

won_the_game - Checks if scoped country won the game
won_the_game = yes
Supported Scopes: country

planet_stability - Compares the stability present on the planet with the given value
planet_stability > 50
Supported Scopes: planet

perc_communications_with_playable - Checks the country's percentage of communications with playable empires
perc_communications_with_playable > 0.3
Supported Scopes: country

planet_crime - Compares the crime present on the planet with the given value
planet_crime > 50
Supported Scopes: planet

has_planetary_ascension_tier - Checks if the planet's ascension tier is as specified:
has_planetary_ascension_tier >= 1
Supported Scopes: planet

num_planetary_ascension_tiers - Checks if the empire has activated as many ascension tiers as specified:
num_planetary_ascension_tiers >= 15
Supported Scopes: country

has_job_type - Checks if the job has a specific type set.
has_job_type = <key>
Supported Scopes: pop job

has_background_job - Checks if the leader's background contains a specific previous job, or any job if set to yes
has_background_job = <key/yes>
Supported Scopes: leader

has_planet_modifier - Checks if the planet has a specific planet modifier
has_planet_modifier = pm_titanic_life
Supported Scopes: planet

is_deposit_type - Checks if deposit is specified type
is_deposit_type = d_immense_engineering_deposit
Supported Scopes: deposit

has_built_species - Checks if country has a built species defined
has_built_species = yes/no
Supported Scopes: country

is_faction_extorted - Checks if the scoped pop faction is extorted
is_faction_extorted = yes/no
Supported Scopes: pop_faction

has_extorted_faction - Checks if the the country has an extorted faction
has_extorted_faction = yes/no
Supported Scopes: country

num_buildings - Checks the number the planet has of any, or a specific, building
num_buildings = {  type = <key/any>  value > 2/variable  disabled = <any(default)/yes(only)/no(only)>  in_construction = <any/no(default)/yes(only)>  category = <any(default)/for example unity or resource> owner_type = <normal/corporate/subject_holding> }
Supported Scopes: planet country

num_districts - Checks the number the planet has of any, or a specific, district
num_districts = { type = <key/any> value > 2/variable }
Supported Scopes: planet country

num_free_districts - Checks the number of available slots the planet has of any, or a specific, district
num_free_districts = { type = <key/any> value > 2/variable }
Supported Scopes: planet

has_planet_flag - Checks if the planet has a specific flag
has_planet_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: planet

has_first_contact_flag - Checks if the first contact site has a specific flag
has_first_contact_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: first_contact

has_situation_flag - Checks if the situation has a specific flag
has_situation_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: situation

has_agreement_flag - Checks if the agreement has a specific flag
has_agreement_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: agreement

has_federation_flag - Checks if the federation has a specific flag
has_federation_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: federation

has_country_flag - Checks if the empire has a specific flag
has_country_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: country

has_fleet_flag - Checks if the fleet has a specific flag
has_fleet_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: fleet

has_ship_flag - Checks if the ship has a specific flag
has_ship_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ship

has_army_flag - Checks if the army has a specific flag
has_army_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: army

has_deposit_flag - Checks if the deposit has a specific flag
has_deposit_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: deposit

has_war_flag - Checks if the war has a specific flag
has_war_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: war

has_starbase_flag - Checks if the starbase has a specific flag
has_starbase_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: starbase

has_sector_flag - Checks if the sector has a specific flag
has_sector_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: sector

has_archaeology_flag - Checks if the archaeological site has a specific flag
has_archaeology_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: archaeological_site

has_spynetwork_flag - Checks if the spy network has a specific flag
has_spynetwork_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: spy_network

has_espionage_asset_flag - Checks if the espionage asset has a specific flag
has_espionage_asset_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_asset

has_astral_rift_flag - Checks if the astral rift has a specific flag
has_astral_rift_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: astral_rift

has_any_flag - Checks if any Flag has been set to the given scope
has_any_flag = yes/no
Supported Scopes: all

is_ship_class - Checks if the ship/fleet/design is a specific class
is_ship_class = shipclass_colonizer
Supported Scopes: ship fleet ship_growth_stage

has_attitude_behavior - Checks if the country has the specified AI behavior towards another country 
has_attitude_behavior = {
	target = <country>
	behavior = attack/weaken/vassalize/alliance/coexist/trade
}
Supported Scopes: country

is_ship_size - Checks if the ship/fleet/design is a specific ship size
is_ship_size = mining_station
Supported Scopes: ship fleet design starbase ship_growth_stage

is_capital - Checks if the planet is its owner's capital
is_capital = yes
Supported Scopes: planet

is_capital_system - Checks if the solar system has its owner's capital
is_capital_system = yes
Supported Scopes: galactic_object

has_ground_combat - Checks if ground combat is taking place on the planet
has_ground_combat = yes
Supported Scopes: planet

is_at_war - Checks if the country is at war
is_at_war = yes
Supported Scopes: country

num_owned_leaders - Checks the country's number of owned (recruited) non-envoy leaders (includes the ruler)
num_owned_leaders < 8
Supported Scopes: country

num_owned_planets - Checks the country's or sector's number of owned planets
num_owned_planets < 8
Supported Scopes: country sector

has_government - Checks if the country has a specific government type, or any government at all
has_government = <yes/any/no/none/type>
Supported Scopes: country

num_unemployed - Checks the number of unemployed pops on the planet or in the entire country
num_unemployed > 301
Supported Scopes: planet country

can_work_specific_job - Checks if the pop group can work a specific job if a vacancy becomes available 
can_work_specific_job = <key>
Supported Scopes: pop pop_group

is_primitive - Checks if the country is a primitive, pre-FTL civilization
is_primitive = yes
Supported Scopes: country

is_archetype - Checks if species has specified archetype:
is_archetype = PRESAPIENT
Supported Scopes: species

is_inside_nebula - checks if the planet/ship/fleet/system is inside a nebula
is_inside_nebula = yes
Supported Scopes: planet ship fleet galactic_object

is_in_frontier_space - checks if the planet/ship/fleet/system is in frontier space
is_in_frontier_space = yes
Supported Scopes: planet ship fleet galactic_object

is_inside_border - Checks if the planet/ship/fleet/system is inside the borders of the target country
is_inside_border = <target>
Supported Scopes: planet ship fleet galactic_object

is_overlord - Checks if the country is the overlord of any subject countries
is_overlord = yes
Supported Scopes: country

is_at_war_with - Checks if the country is at war with the target country
is_at_war_with = <target>
Supported Scopes: country

their_opinion - Checks target country's opinion value of the current country
their_opinion = { who = <target> value > 25/variable }
Supported Scopes: country

is_same_species_class - Checks if the pop group/country is of the same species class as another pop group/country
is_same_species_class = <target>
Supported Scopes: country ship pop pop_group leader army species

has_federation - Checks if the country is in a federation
has_federation = yes
Supported Scopes: country

is_colonizable - Checks if the planet can theoretically be colonized
is_colonizable = yes
Supported Scopes: planet

num_minerals - Checks the planet's total amount of minerals
num_minerals < 20
Supported Scopes: planet

num_physics - Checks the planet's total amount of physics research
num_physics = 8
Supported Scopes: planet

num_society - Checks the planet's total amount of society research
num_society > 8
Supported Scopes: planet

num_engineering - Checks the planet's total amount of engineering research
num_engineering < 8
Supported Scopes: planet

num_modifiers - Checks the planet's number of modifiers
num_modifiers < 3
Supported Scopes: planet

has_any_strategic_resource - Checks if the planet has any strategic resource
has_any_strategic_resource = yes
Supported Scopes: planet

has_pop_flag - Checks if the pop has a specific flag
has_pop_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop

has_pop_group_flag - Checks if the pop group has a specific flag
has_pop_group_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop_group

is_occupied_flag - Checks if the planet is under military occupation
is_occupied_flag = yes
Supported Scopes: planet

is_damaged - Checks if the ship is damaged
is_damaged = yes
Supported Scopes: ship

has_hp - Checks the ship's hull points
has_hp > 200
Supported Scopes: ship

has_shield_hp - Checks the ship's shield hit points
has_shield_hp > 200
Supported Scopes: ship

has_max_hp - Checks the ship's max hull points
has_max_hp > 200
Supported Scopes: ship

has_max_armor_hp - Checks the ship's max armor hit points
has_max_armor_hp > 200
Supported Scopes: ship

is_surveyed - Checks if the planet/astral_rift/system has been survey by target country
is_surveyed = { who = <target> status = yes }
Supported Scopes: planet galactic_object astral_rift

has_global_flag - Checks if a Global Flag has been set
has_global_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: all

is_variable_set - Checks if the specified variable is set on the current scope. Use to avoid unset variables errors
is_variable_set = my_var
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

check_variable - Checks a variable for the country/leader/planet/system/fleet
check_variable = { which = <variable> value >=< <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

check_variable_arithmetic - Checks a variable for the scope if a certain amount of arithmetic is done to it (note: the variable's value is not changed by this trigger)
check_variable_arithmetic = {
	which = <variable>
	add/subtract/multiply/divide/modulo = <float>/<variable>/<scope.variable>/trigger:<trigger> (note: this line can be repeated as many times as desired)
	value <=> <float>/<variable>/<scope.variable>/trigger:<trigger> (the value to compare against)
}
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

check_modifier_value - Checks the value of a specified modifier in the current scope against a value.
check_modifier_value = { modifier = logistic_growth_mult value > 1.05/variable
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army species design pop_faction spy_network espionage_operation

check_economic_production_modifier_for_job - Checks the value of economic production modifiers a pop has for producing a certain resource via a certain job. Can specify checking all modifiers or just those from traits. WARNING: expensive trigger
check_economic_production_modifier_for_job = {
	job = miner
	resource = minerals
	resource = { minerals = 0.5 energy = 0.5 } (for evaluating the bonuses to multiple resources, with weights)
	species_modifiers_only = no (default: yes - only checks trait modifiers, trait triggered pop modifiers, and species habitability)
	value > 1.25
}
Supported Scopes: planet pop_group

check_galaxy_setup_value - Checks the value for a specific option from the galaxy setup 
check_galaxy_setup_value = { setting = <string> value >=< <float>/<variable> }
possible values: num_empires, num_advanced_empires, num_fallen_empires, num_marauder_empires, mid_game_year, end_game_year, victory_year, num_guaranteed_colonies, num_gateways, num_wormhole_pairs, num_hyperlanes, habitable_worlds_scale, primitive_worlds_scale, crisis_strength_scale, tech_costs_scale
Supported Scopes: all

is_colony - Checks if the planet is colonized
is_colony = yes
Supported Scopes: planet

habitability - Checks the planet's habitability (0 to 1) for target pop group/species
habitability = { who = <target> value = 0.6 }
Supported Scopes: planet

has_building - Checks if the planet has any, or a specific, building
has_building = yes
has_building = building_capital_3
Supported Scopes: planet

has_holding - Checks if the planet has any, or a specific, holding
has_holding = { holding = any/none/<holding> owner = <owner> }
Supported Scopes: planet

has_active_building - Checks if the planet has a specific building, and that that building is not disabled or ruined.
has_active_building = building_capital_3
Supported Scopes: planet

is_controlled_by - Checks if the planet/ship/fleet/astral rift is controlled by the target country
is_controlled_by = <target>
Supported Scopes: planet ship fleet astral_rift

is_terraformed - Checks if the planet has ever been terraformed
is_terraformed = yes
Supported Scopes: planet

is_terraforming - Checks if the planet is currently being terraformed
is_terraforming = yes
Supported Scopes: planet

is_federation_leader - Checks if the country is the leader of their federation
is_federation_leader = yes
Supported Scopes: country

is_mobile - Checks if the scoped fleet can move.
is_mobile = <yes/no>
Supported Scopes: fleet

is_in_sensor_range - Checks if the specified ship, fleet, planet or system can be seen by the scoped country.
is_in_sensor_range = <ship/fleet/system>
Supported Scopes: country

is_in_sensor_range_of_country - Checks if the scoped ship, fleet, planet or system can be seen by the specified country.
is_in_sensor_range_of_country = root.owner
Supported Scopes: planet ship fleet galactic_object

has_star_flag - Checks if the solar system has a specific flag
has_star_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: galactic_object dlc_recommendation

has_mining_station - Checks if the planet has an orbital mining station
has_mining_station = yes
Supported Scopes: planet

has_research_station - Checks if the planet has an orbital research station
has_research_station = yes
Supported Scopes: planet

army_type - Checks the army's type
army_type = assault_army
Supported Scopes: army

is_defensive_army - Checks if the army is defensive
is_defensive_army = yes
Supported Scopes: army

has_army - Checks if the planet has an army
has_army = yes
Supported Scopes: planet

is_advisor_active - Checks if a country has an advisor
is_advisor_active = yes
Supported Scopes: country

is_idle - Checks if scoped leader is idle
is_idle = yes
Supported Scopes: leader

income - Checks the country's monthly energy credit income
income < 90
Supported Scopes: country

expenses - Checks the country's monthly energy credit expenses
expenses > 28
Supported Scopes: country

num_uncleared_blockers - Checks the planet's total amount of uncleared blockers
num_uncleared_blockers > 3
Supported Scopes: planet

num_envoys_to_federation - Checks the country's number of envoys sent to its federation
num_envoys_to_federation < 2
Supported Scopes: country

num_envoys_to_galcom - Checks the country's number of envoys sent to the galactic community
num_envoys_to_galcom < 2
Supported Scopes: country

has_envoy_task - Checks the scoped leader's diplomatic/envoy task.
has_envoy_task = {
	task = improve_relations/harm_relations/federation/galactic_community/spy_network/first_contact/strengthen_imperial_authority/undermine_imperial_authority/none
	target = <country> (optional)
}
Supported Scopes: leader

has_envoy_cooldown - Checks the scoped envoy currently has a cooldown on its status.
has_envoy_cooldown = yes/no
Supported Scopes: leader

has_anomaly - Checks if the planet has an anomaly
has_anomaly = yes
Supported Scopes: planet

stored_physics_points - Checks the country's amount of stored physics research
stored_physics_points
Supported Scopes: country

stored_society_points - Checks the country's amount of stored society research
stored_society_points
Supported Scopes: country

stored_engineering_points - Checks the country's amount of stored engineering research
stored_engineering_points
Supported Scopes: country

running_balance - Checks the country's running energy credit balance
running_balance > 61
Supported Scopes: country

is_planet - Checks if the planet is the same as target planet
is_planet = <target>
Supported Scopes: planet

is_ship - Checks if the ship is the same as target ship
is_ship = <target>
Supported Scopes: ship

is_army - Checks if the army is the same as target army
is_army = <target>
Supported Scopes: army

is_country - Checks if the country is the same as target country
is_country = <target>
Supported Scopes: country

is_tutorial_level - Checks the country's tutorial level (0 off, 1 limited, 2 full)
is_tutorial_level = 0
Supported Scopes: country

is_multiplayer - Checks if the game is running in multiplayer
is_multiplayer = yes
Supported Scopes: all

has_event_chain - Checks if the country has a specific event chain
has_event_chain = old_gods_chain
Supported Scopes: country

has_completed_event_chain - Checks if the country has completed a specific event chain
has_completed_event_chain = <event_chain_key>
Supported Scopes: country

is_species_class - Checks if the pop group/country's founder species is a specific species class
is_species_class = MAM
Supported Scopes: country pop pop_group species dlc_recommendation

has_opinion_modifier - Checks if the country has a specific opinion modifier towards target country or anyone
has_opinion_modifier = { who = <target (optional)> modifier = encroaching_colony is_reverse = no }
Supported Scopes: country

has_established_contact - Checks if the country has established contact with target country
has_established_contact = <target>
Supported Scopes: country

has_completed_event_chain_counter - Checks if the country has completed a specific counter in an event chain
has_completed_event_chain_counter = { event_chain = amoebas_2_chain counter = amoebas_slaughtered }
Supported Scopes: country

has_planet_class - Checks if the system has planet of specific class
has_planet_class = pc_tundra/<scope>
Supported Scopes: galactic_object

is_disabled - Checks if the ship/fleet is disabled
is_disabled = yes
Supported Scopes: ship fleet

has_existing_ship_design - Checks if the country has a specific ship design available
Supported Scopes: country

has_resource - Checks if the planet has a specific amount of a specific resource
has_resource = { type = minerals amount < 5 }
has_resource = no
Supported Scopes: planet country deposit astral_rift

has_building_construction - Checks if the planet has any, or a specific, ongoing building construction
has_building_construction = yes
has_building_construction = building_capital_3
Supported Scopes: planet

num_fallen_empires_setting - Checks the number of fallen empires defined in setup
num_fallen_empires_setting > 1
Supported Scopes: all

free_building_slots - Checks the planet's number of slots available for new constructions
free_building_slots > 2
Supported Scopes: planet

has_relation_flag - Checks if the country has a relation flag towards target country
has_relation_flag = {
	who = <target>
	flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

reverse_has_relation_flag - Checks if the target country has a relation flag towards the country
reverse_has_relation_flag = {
	who = <target>
	flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

has_moon - Checks if the planet has a moon
has_moon = yes
Supported Scopes: planet

num_moons - Checks the planet's number of moons
num_moons < 4
Supported Scopes: planet

is_sapient - Checks if the pop group or species is sapient
is_sapient = no
Supported Scopes: pop_group species

inherits_parent_rights - Checks if the pop group or species inherits the base species' rights. Returns false if there is no parent species.
inherits_parent_rights = no
Supported Scopes: pop_group species

is_preventing_anomaly - Checks if the planet is prevented from generating anomalies
is_preventing_anomaly = yes
Supported Scopes: planet

has_deposit_for - Checks if the planet has a deposit for a specific ship class
has_deposit_for = shipclass_mining_station
Supported Scopes: planet

colony_age - Checks the planet's (colony's) age in months
colony_age > 12
Supported Scopes: planet

colony_age_years - Checks the planet's (colony's) age in years
colony_age_years > 12
Supported Scopes: planet

is_bottleneck_system - Checks if the system is bottleneck within the range NDefines::NGameplay::SYSTEM_BOTTLENECK_RADIUS
is_bottleneck_system = yes
Supported Scopes: galactic_object

is_rim_system - Checks if the system is on the galactic rim
is_rim_system = yes
Supported Scopes: galactic_object

is_country_type - Checks if the country is a specific type
is_country_type = fallen_empire
Supported Scopes: country

has_modifier - Checks if the scope object has a certain modifier
has_modifier = <modifier>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift

mission_progress - Checks if the observation post has achieved specific progress in a mission
mission_progress > 0.7
Supported Scopes: fleet

num_ethics - Checks the country/pop group's number of ethics
num_ethics = 3
Supported Scopes: country pop pop_group

num_traits - Checks the country/pop group/leader/species' number of traits
num_traits < 3
Supported Scopes: country pop pop_group leader species

has_truce - Checks if the country has a truce with target country
has_truce = <target>
Supported Scopes: country

can_access_system - Checks if the scoped fleet is able to enter the system. Note: Avoid overusing this, it is a performance-intensive trigger!
can_access_system = <solar system>
Supported Scopes: fleet

is_ringworld - Checks if the planet is a ringworld
is_ringworld = yes
Supported Scopes: planet

member_of_faction - Checks if the pop group belongs to any, or a specific, faction
member_of_faction = no/<pop faction scope>/isolationist
Supported Scopes: pop pop_group

support - Checks the support level of a faction, or that of a leader's faction(s)
 support > 0.5
Supported Scopes: leader pop_faction

is_ideal_planet_class - Checks if the planet is of the ideal class for target country, species or pop
is_ideal_planet_class = { who = <target> status = yes/no }
Supported Scopes: planet

is_pop_faction_type - Checks the faction's type
is_pop_faction_type = isolationist
Supported Scopes: pop_faction

intel_level - Checks the country's intel level of target system
intel_level = { level > low system = <target> }
Supported Scopes: country

situation_progress - Checks if the scoped situation's progress is a certain value.
situation_progress > 15
Supported Scopes: situation

situation_monthly_progress - Checks if the scoped situation's monthly progress is a certain value. Returns the cached value from the last monthly tick.
situation_monthly_progress > 1
Supported Scopes: situation

is_situation_type - Checks if the scoped situation is a certain type.
is_situation_type = my_situation_type
Supported Scopes: situation

current_situation_approach - Checks if the specified approach has been picked on the scoped situation.
current_situation_approach = <approach> (name field of the approach)
Supported Scopes: situation

can_set_situation_approach - Checks if the specified approach is allowed to be picked (according to potential and allow triggers) on the scoped situation.
can_set_situation_approach = <approach> (name field of the approach)
Supported Scopes: situation

has_faction - Checks if the country has any instance of target faction type
has_faction = isolationist
Supported Scopes: country

can_declare_war - Checks if the country can declare war against target country
can_declare_war = {
	target = <target country>
	attacker_war_goal = <war goal>
}
Supported Scopes: country

is_hostile - Checks if the country is hostile towards target country
is_hostile = <target>
Supported Scopes: country

is_forced_neutral - Checks if the country has been set to be neutral towards target country via set_faction_hostility
is_forced_neutral = <target>
Supported Scopes: country

is_forced_friendly - Checks if the country has been set to be friendly towards target country via set_faction_hostility
is_forced_friendly = <target>
Supported Scopes: country

has_communications - Checks if the country has established communications with target country
has_communications = <target>
Supported Scopes: country

has_country_resource - Checks the country's amount of a specific stored resource
has_country_resource = { type = minerals amount > 99/variable }
Supported Scopes: country

has_leader_flag - Checks if the leader has a specific flag
has_leader_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: leader

num_killed_ships - Checks how many of target country's ships that the country has destroyed
num_killed_ships = { target = <target> value > 5/variable }
Supported Scopes: country

num_taken_planets - Checks how many planets the country has taken from target country
num_taken_planets = { target = <target> value > 1 }
Supported Scopes: country

is_scope_valid - Checks if the current scope is valid
is_scope_valid = yes
Supported Scopes: all

opposing_ethics_divergence - Checks how far removed the country/pop group's ethos is from target's
opposing_ethics_divergence = { steps > 1/variable who = <target> }
Supported Scopes: country pop pop_group

is_war_leader - Checks if the country leads in a war
is_war_leader = yes
Supported Scopes: country pop_faction

is_in_federation_with - Checks if the country is in a federation with target country
is_in_federation_with = <target>
Supported Scopes: country

can_change_policy - Checks if the country can change a specific policy
can_change_policy = slavery
Supported Scopes: country

is_ironman - Check if current game is running in ironman mode
is_ironman = yes
Supported Scopes: all

species_gender - Checks what gender settings the species allows.
species_gender = female/male/indeterminable/not_set
Supported Scopes: species

has_monthly_income - Checks the country's monthly income of a specific resource
has_monthly_income = { resource = engineering_research  value < 20 }
Supported Scopes: country

else - Evaluates the triggers if the display_triggers of preceding 'if' or 'else_if' is not met
if = { limit = { <display_triggers> } <triggers> }
 else = { <triggers> }
Supported Scopes: all

has_policy_flag - Checks if the country has a specific policy
has_policy_flag = slavery_not_allowed
Supported Scopes: country

count_deposits - Checks the number of deposits on the planet that meet the specified criteria
count_deposits = { type = <deposit> category = <category> count < 2 }
Supported Scopes: planet

count_species_traits - Checks the number of unique traits within the set parameters on a species or pop group
count_species_traits = { limit = {} category = <category> cost < = > <trait cost> | count < 2 }
Supported Scopes: pop pop_group species

has_tech_option - Checks if the country has a tech research option currently available
has_tech_option = tech_mining_network_2
Supported Scopes: country

count_tech_options - Checks the country's number available tech research options in a specific field
count_tech_options = { area = physics count > 0/variable }
Supported Scopes: country

has_point_of_interest - Checks if the scoped country has a specific point of interest in its situation log
has_point_of_interest = { poi = <id> }
Supported Scopes: planet country ship fleet galactic_object ambient_object

is_being_repaired - Checks if the ship/fleet is being repaired
is_being_repaired = yes
Supported Scopes: ship fleet

compare_distance - Checks whether the current scope is closer to a specified object than it is to a second specified object within the same solar system.
compare_distance = { closer_object = root further_object = from }
Supported Scopes: megastructure planet ship pop pop_group fleet galactic_object leader ambient_object starbase deposit archaeological_site first_contact

has_ambient_object_flag - Checks if the ambient object has a specific flag
has_ambient_object_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ambient_object

is_ambient_object_type - Checks if the ambient object is a specific type.
is_ambient_object_type = caravaneer_billboard_1
Supported Scopes: ambient_object

galaxy_percentage - Checks if the country has a specific percentage (0.00-1.00) of the galaxy within its borders
galaxy_percentage > 0.40
Supported Scopes: country

custom_tooltip_fail - Shows custom text only when the associated trigger fails
custom_tooltip_fail = {
	text = <text>
	<triggers>
}
Supported Scopes: all

custom_progress - Adjusts progress of triggers inside it
custom_progress = {
	...
	current_val_coeff = 0.5
	final_val_coeff = 0.5
	mode = <normal/simplified/clamped>
}
Supported Scopes: all

hidden_progress - Nullifies progress of triggers inside it and returns progress '0 of 0'
hidden_progress = {
	<triggers>
}
Supported Scopes: all

simple_progress - Hides the progress of the triggers inside and returns progresses '0 of 1' or '1 of 1'
simple_progress = {
	<triggers>
}
Supported Scopes: all

is_in_combat - Checks if the ship/fleet is engaged in combat
is_in_combat = yes
Supported Scopes: ship fleet

is_in_frontline - Checks if the army is currently in the frontline of a combat
is_in_frontline = yes
Supported Scopes: army

is_guaranteeing - Checks if the country is guaranteeing the independence of target country
is_guaranteeing = <target>
Supported Scopes: country

is_war_participant - Checks if target country is participating in the war on the specified side
is_war_participant = { who = <target>/war = <target> side = attackers/defenders/<target> }
Supported Scopes: country war

is_homeworld - Checks if the planet is its owner's homeworld
is_homeworld = yes
Supported Scopes: planet

is_friendly_to - Checks if the country has a friendly attitude towards target country
is_friendly_to = <target>
Supported Scopes: country

is_hostile_to - Checks if the country has a hostile attitude towards target country
is_hostile_to = <target>
Supported Scopes: country

is_protective_to - Checks if the country has a protective attitude towards target country
is_protective_to = <target>
Supported Scopes: country

is_threatened_to - Checks if the country has a threatened attitude towards target country
is_threatened_to = <target>
Supported Scopes: country

years_passed - Checks the number of in-game years passed since the 2200 start
years_passed < 150
Supported Scopes: all

mid_game_years_passed - Checks the number of in-game years passed since the mid-game start date
mid_game_years_passed >= 50
Supported Scopes: all

end_game_years_passed - Checks the number of in-game years passed since the end-game start date
end_game_years_passed >= 50
Supported Scopes: all

is_dismissive_to - Checks if the country has a dismissive attitude towards target country
is_dismissive_to = <target>
Supported Scopes: country

is_patronizing_to - Checks if the country has a patronizing attitude towards target country
is_patronizing_to = <target>
Supported Scopes: country

is_angry_to - Checks if the country has an angry attitude towards target country
is_angry_to = <target>
Supported Scopes: country

is_neighbor_of - Checks if the country/planet is neighbors with target country
is_neighbor_of = <target>
Supported Scopes: planet country ship fleet galactic_object

is_rival - Checks if the country has a rival attitude towards target country
is_rival = <target>
Supported Scopes: country

is_unfriendly_to - Checks if the country has an unfriendly attitude towards target country
is_unfriendly_to = <target>
Supported Scopes: country

is_loyal_to - Checks if the country has a loyal attitude towards target country
is_loyal_to = <target>
Supported Scopes: country

is_disloyal_to - Checks if the country has a disloyal attitude towards target country
is_disloyal_to = <target>
Supported Scopes: country

is_cordial_to - Checks if the country has a cordial attitude towards target country
is_cordial_to = <target>
Supported Scopes: country

is_domineering_to - Checks if the country has a domineering attitude towards target country
is_domineering_to = <target>
Supported Scopes: country

fleet_power - Checks the scope's total fleet power
fleet_power > 2500
Supported Scopes: country fleet federation

has_election_type - Checks if the country has a specific election type
has_election_type = oligarchic
Supported Scopes: country

is_background_planet - Check if a planet is the background planet of a leader 
is_background_planet = <target>
Supported Scopes: leader

has_ai_personality - Checks if an AI empire has a certain personality type
has_ai_personality = fanatic_befrienders
Supported Scopes: country

has_ai_personality_behaviour - Checks if a country has a certain AI personality behavior
has_ai_personality_behaviour = slaver
Supported Scopes: country

has_valid_ai_personality - Checks if the country has a valid AI personality
has_valid_ai_personality = yes
Supported Scopes: country

has_migration_access - Checks if the country has migration access to target country
has_migration_access = <target>
Supported Scopes: country

logged_in_to_pdx_account - Checks if the local human is logged in to a Pdx account. This WILL cause an out of sync if used for anything that can change the game state
Supported Scopes: all

would_join_war - Checks if the country would join the side of target country in a hypothetical war
would_join_war = { attacker = <target> defender = <target> side = <target> }
Supported Scopes: country

count_war_participants - Checks the number of participants in the war on a specific side that meet the specified criteria
count_war_participants = { limit = { <triggers> } side = target count < 4/variable
Supported Scopes: war

count_potential_war_participants - Checks the amount of potential war participants in a specific war that meet the specified criteria
count_potential_war_participants = { attacker = <target> defender = <target> side = <target> limit = { <triggers> } count > 2/variable
Supported Scopes: all

has_base_skill - Checks if the leader has a specific base experience level
has_base_skill > 2
Supported Scopes: leader

has_total_skill - Checks if the leader has a specific total (base + effective) experience level
has_total_skill > 2
Supported Scopes: leader

has_experience - Checks if the leader has a specific amount of experience
has_experience < 900
Supported Scopes: leader

is_under_colonization - Checks if the planet is being colonized
is_under_colonization = yes
Supported Scopes: planet

distance_to_empire - Checks the ship/fleet/planet/system's galaxy map distance to target empire
distance_to_empire = {
	who = <target>
	distance = x
	use_bypasses = no (default: yes)
	type = hyperlane/euclidean (default: hyperlane)
}
Supported Scopes: planet ship fleet galactic_object

years_of_peace - Checks the number of in-game years country has been at peace, with optional parameter to delay from start of game
years_of_peace = { value > 10/variable delay = 0 }
Supported Scopes: country

is_within_borders_of - Checks if the planet/system/fleet/ship is within the borders of the target country
is_within_borders_of = <target>
Supported Scopes: planet ship fleet galactic_object

num_marauder_empires_to_spawn - Checks the number of marauder empires specified by the galaxy setup
num_marauder_empires_to_spawn > 1
Supported Scopes: all

has_species_flag - Checks if the species has a specific flag
has_species_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: species

has_auto_move_target - Checks if the fleet/ship has an active auto-move target set
has_auto_move_target = yes
Supported Scopes: ship fleet

count_starbase_modules - Checks the number of starbase modules that are of the specified type or not
count_starbase_modules = { type = anchorage (optional) include_being_constructed = yes/no count < 12/variable }
Supported Scopes: country galactic_object starbase

count_starbase_buildings - Checks the number of starbase buildings that are of the specified type or not
count_starbase_buildings = { type = command_center (optional) include_being_constructed = yes/no count < 12/variable }
Supported Scopes: country galactic_object starbase

is_belligerent_to - Checks if the country has a belligerent attitude towards target country
is_belligerent_to = <target>
Supported Scopes: country

is_imperious_to - Checks if the country has a imperious attitude towards target country
is_imperious_to = <target>
Supported Scopes: country

is_arrogant_to - Checks if the country has a arrogant attitude towards target country
is_arrogant_to = <target>
Supported Scopes: country

has_association_status - Check if the country has federation association status with target country
has_association_status = <target>
Supported Scopes: country

is_original_owner - Checks if the target country is the planet's original owner
is_original_owner = <target>
Supported Scopes: planet

subject_can_diplomacy - Checks if the current country is allowed by its overlord to take diplomatic action
subject_can_diplomacy = <target>
Supported Scopes: country

has_surveyed_class - Checks if the country has surveyed any planet of a specific class
has_surveyed_class = pc_tundra
Supported Scopes: country

fleet_size - Checks the fleet's fleet size
fleet_size < 125
Supported Scopes: fleet

host_has_dlc - Checks if the host has a specific DLC enabled
Supported Scopes: all

local_has_dlc - Checks if the local player has a specific DLC enabled
Supported Scopes: all

num_rare_techs - Checks the country's number of researched rare technologies
num_rare_techs < 4
Supported Scopes: country

num_dangerous_techs - Checks the country's number of researched dangerous technologies
num_dangerous_techs < 4
Supported Scopes: country

num_insight_techs - Checks the country's number of researched insight technologies
num_insight_techs < 4
Supported Scopes: country

num_custom_1_techs - Checks the country's number of researched custom_1 technologies
num_custom_1_techs < 4
Supported Scopes: country

num_custom_2_techs - Checks the country's number of researched custom_2 technologies
num_custom_2_techs < 4
Supported Scopes: country

num_custom_3_techs - Checks the country's number of researched custom_3 technologies
num_custom_3_techs < 4
Supported Scopes: country

num_repeatable_techs - Checks the country's number of researched repeatable technologies
num_repeatable_techs < 4
Supported Scopes: country

num_researched_techs - Checks the country's number of researched technologies
num_researched_techs > 21
Supported Scopes: country

num_researched_techs_of_tier - Checks the country's number of researched technologies of a certain tier
num_researched_techs_of_tier = { tier = 2 value > 21
Supported Scopes: country

can_research_tier - Checks whether the country can research a certain tech tier
can_research_tier = { tier = 1 area = society }
Supported Scopes: country

nor - An inverted OR trigger
Supported Scopes: all

nand - An inverted AND trigger
Supported Scopes: all

num_energy - Checks the planet's total amount of energy
num_energy > 19
Supported Scopes: planet

num_armies - Checks the country's or planet's number of armies
num_armies < 20
Supported Scopes: planet country

has_war_goal - Checks if a war goal is set. Only works in diplomatic phrases.
has_war_goal = yes
Supported Scopes: all

max_naval_capacity - Checks the country's max naval capacity in absolute numbers
max_naval_capacity > 120
Supported Scopes: country

used_naval_capacity_integer - Checks the country's used naval capacity in absolute numbers
used_naval_capacity_integer < 89
Supported Scopes: country

used_naval_capacity_percent - Checks the country's used naval capacity in relative terms (0.00-1.00)
used_naval_capacity_percent < 0.75
Supported Scopes: country

max_starbase_capacity - Checks the country's max starbase capacity
max_starbase_capacity = 15
Supported Scopes: country

used_starbase_capacity_integer - Checks the country's used starbase capacity in absolute numbers
used_starbase_capacity_integer = 15
Supported Scopes: country

used_starbase_capacity_percent - Checks the country's used starbase capacity in relative terms (0.00-1.00)
used_starbase_capacity_percent < 0.75
Supported Scopes: country

used_defense_platform_capacity_percent - Checks the starbases's used defense platform capacity in relative terms (0.00-1.00)
used_defense_platform_capacity_percent < 0.75
Supported Scopes: starbase

war_begun_num_fleets_gone_mia - Checks amount of target country's fleets that went MIA when the war began
war_begun_num_fleets_gone_mia = { who = <target> value < 10 }
Supported Scopes: war

custom_tooltip_success - Shows custom text only when the associated trigger passes
custom_tooltip_success = {
	text = <text>
	<triggers>
}
Supported Scopes: all

has_active_event - Checks if country has active events:
has_active_event = {
	event.1
	event.2
	event.n
}
Supported Scopes: country

success_text - For 'desc={trigger={' use. Shows custom text when the associated trigger passes.
success_text = {
	text = <text>
	<triggers>
}
Supported Scopes: all

fail_text - For 'desc={trigger={' use. Shows custom text when the associated trigger fails.
fail_text = {
	text = <text>
	<triggers>
}
Supported Scopes: all

has_defensive_pact - Checks if the country has a defensive pact with target country
has_defensive_pact = <target>
Supported Scopes: country

calc_true_if - Returns true if the specified number of sub-triggers return true
calc_true_if = { amount = 2/variable <trigger> <trigger> <trigger> }
Supported Scopes: all

is_researching_technology - Checks if the country is currently researching a specific technology
is_researching_technology = tech_gene_seed_purification
Supported Scopes: country

is_subject - Checks if the country is a subject of any other country
is_subject = no
Supported Scopes: country

log - Prints a message to game.log for debugging purposes
log = <string>
Supported Scopes: all

is_enigmatic_to - Checks if the country has a enigmatic attitude towards target country
is_enigmatic_to = <target>
Supported Scopes: country

is_berserker_to - Checks if the country has a berserker attitude towards target country
is_berserker_to = <target>
Supported Scopes: country

has_same_ethos - Checks if a country has the same ethos (complete set of ethics) as a country or pop group
has_same_ethos = <target>
Supported Scopes: country pop pop_group

is_majority_species - Checks if the specified species is the majority species on the current planet.
is_majority_species = <species>
Supported Scopes: planet

has_closed_borders - Check if the country has closed its borders to target country
has_closed_borders = <target>
Supported Scopes: country

is_difficulty - Checks the game's difficulty level (0 to 6, with 0 as Civilian and 6 as Grand Admiral)
is_difficulty = 2
Supported Scopes: all

is_exact_same_species - Checks if the scoped object is originally of the same species, or currently of the exact same species instance, as another object
is_exact_same_species = <target>
Supported Scopes: country ship pop pop_group leader army species

can_control_access_for - Checks if the country is allowed to control target country's border access to the country
can_control_access_for = <target>
Supported Scopes: country

is_overlord_to - Checks if the country has an overlord attitude towards target country
is_overlord_to = <target>
Supported Scopes: country

is_improving_relations_with - Checks if the country has an envoy sent to the target country to improve relations
is_improving_relations_with = <target>
Supported Scopes: country

is_harming_relations_with - Checks if the country has an envoy sent to the target country to harm relations
is_harming_relations_with = <target>
Supported Scopes: country

distance_to_core_percent - Checks the ship/fleet/planet/leader/pop/system's distance to the galactic core in percent, where center = 0 and galactic rim = 100
distance_to_core_percent < 60
Supported Scopes: all

distance_to_capital - Checks the distance of a controlled system to its owner's capital
distance_to_capital > 5
Supported Scopes: planet galactic_object

has_non_aggression_pact - Check if the country has a non-aggression pact with target country
has_non_aggression_pact = <target>
Supported Scopes: country

happiness_planet - Checks the average happiness on the planet
happiness_planet < 0.6
Supported Scopes: planet

has_hp_percentage - Checks a fleet or ship's hit points percentage
has_hp_percentage > 0.5
Supported Scopes: ship fleet

has_armor_percentage - Checks a fleet or ship's armor hit points percentage
has_armor_percentage > 0.5
Supported Scopes: ship fleet

has_shield_percentage - Checks a fleet or ship's shield hit points percentage
has_shield_percentage > 0.5
Supported Scopes: ship fleet

can_join_factions - Checks if scoped pop group can join a faction
Supported Scopes: pop pop_group

is_custodial_to - Checks if the country has a custodial attitude towards target country
is_custodial_to = <target>
Supported Scopes: country

num_pops_assigned_to_job - Checks the number of pops assigned to the job (in total or from a specific pop group)
num_pops_assigned_to_job = {
	pop_group = <target> (if not specified, check total number)
	value < 300
}
Supported Scopes: pop job

has_valid_civic - Checks if the current country has a certain civic and if its validated
has_valid_civic = my_test_civic_1
Supported Scopes: country

has_active_tradition - Checks if a country has the given tradition or tradition swap. Tradition specified must be the one giving effects, i.e. tradition swaps with 'inherit_effects = yes' are ignored and the base tradition should be specified in those cases.
has_active_tradition = tr_my_santa_claus_tradition
Supported Scopes: country

num_tradition_categories - Checks number of tradition categories the country has picked
num_tradition_categories > 2
Supported Scopes: country

is_event_leader - Checks if a leader is a special event leader (defined in create_leader)
is_event_leader = no
Supported Scopes: leader

is_crises_allowed - Check if current game allows crises
is_crises_allowed = yes
Supported Scopes: all

allowed_crisis_type - Checks which crisis is allowed to spawn in the current game
allowed_crisis_type = prethoryn/unbidden/contingency/synth_queen/all
Supported Scopes: all

is_custom_capital_location - Checks if the spatial object is its owner's custom capital location
is_custom_capital_location = yes
Supported Scopes: planet ship fleet galactic_object

resource_income_to_expenditure_balance_ratio - Checks ratio between the country's income and expenditures for a specific resource. E.g. if it makes 80 energy and spends 100, its ratio is 0.8.
resource_income_to_expenditure_balance_ratio = {
	resource = <resource_name>
	category = <category_name> # Optional; if not provided, will use sum for all Categories
	value ><= <value>
}
Supported Scopes: country

resource_stockpile_compare - Checks specific resource stockpile for the country scope:
resource_stockpile_compare = {
	resource = <resource_name>
	value ><= <value>
	mult = <variable> (optional: multiply the value by a variable, e.g. for when you are doing the same with add_resource)
}
Supported Scopes: country

planet_resource_compare - Checks specific resource value for scoped planet. Warning: performance-intensive trigger!
planet_resource_compare = {
	resource = <resource_name>
	value ><= <value>/variable>
	type = upkeep/produces/balance(default)
}
Supported Scopes: planet

resource_income_compare - Checks specific resource income value for the country scope (note: checks profit minus loss, not revenue):
resource_income_compare = {
	resource = <resource_name>
	value ><= <value>
}
Supported Scopes: country

resource_expenses_compare - Checks specific resource expenses value for the country scope:
resource_expenses_compare = {
	resource = <resource_name>
	category = <category_name> # Optional; if not provided, will use sum for all Categories
	value ><= <value>
}
Supported Scopes: country

resource_revenue_compare - Checks specific resource revenue value for the country scope:
resource_revenue_compare = {
	resource = <resource_name>
	category = <category_name> # Optional; if not provided, will use sum for all Categories
	value ><= <value>
}
Supported Scopes: country

market_resource_price - Checks market price of a specific resource for the current country:
market_resource_price = {
	resource = <resource_name>
	amount = <value> (how much are you buying/selling)
	trade_type = market_buy/market_sell/not_set (i.e. price without market fees)
	value ><= <value>/<variable>
}
Supported Scopes: country

pop_amount_percentage - Checks the percentage of pops in the scope that fulfill the specified criteria
pop_amount_percentage = {
	percentage > 0.74/variable
	limit = { <triggers> }
	exclude = { <triggers> } (optional: specifies pop groups to exclude from the calculation)
}
Supported Scopes: planet country pop_faction sector

num_species - Checks if the number of species on a planet, in an empire or in a pop faction is according to the argument. Does not count genetically modified species as unique.
num_species > 8
Supported Scopes: planet country pop_faction

num_unique_species - Checks if the number of species on a planet, in an empire or in a pop faction is according to the argument. Counts genetically modified species as unique.
num_unique_species < 12
Supported Scopes: planet country pop_faction

has_diplo_migration_treaty - Checks if two countries have a migration treaty.
Supported Scopes: country

has_presence - Checks if a system contains any fleets, stations, mega structures or colonized planets.
has_presence = yes
Supported Scopes: galactic_object

is_megastructure_type - Compares the type of scope's mega structure to a type from the database.
is_megastructure_type = <name of type>
Supported Scopes: megastructure

is_upgrading - Checks if the scope's fleet or mega structure is currently upgrading.
is_upgrading = <yes/no>
Supported Scopes: megastructure fleet

can_be_upgraded - Checks if the scope's fleet, ship, starbase or megastructure can be upgraded.
can_be_upgraded = <yes/no>. 
Supported Scopes: megastructure ship fleet starbase

relative_power - Compares relative power between two countries. relative_power = { who = <target country> category = <fleet/economy/technology/all> value ><= <pathetic/inferior/equivalent/superior/overwhelming>
Supported Scopes: country federation

has_tradition - Checks if a country has the given tradition.
has_tradition = tr_my_santa_claus_tradition
Supported Scopes: country

is_job_of_pop_category - Checks if a job is of a certain pop category. Note that the result for this trigger is not dependent on where it is used - so it's for use in e.g. templated script values.
is_job_of_pop_category = { job = <job> category = <category> }
Supported Scopes: all

has_megastructure_flag - Checks if the mega structure has a specific flag
has_megastructure_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure

has_citizenship_type - Checks if a species/pop group/leader has a particular citizenship type in their country
has_citizenship_type = { country = <who> type = <type> }
Supported Scopes: pop pop_group leader species

former_colonization_control_type - Compares the former migration control type with the given one.
former_colonization_control_type = colonization_control_yes
Supported Scopes: pop pop_group

has_population_control - Checks if the pop group is prevented from reproducing
has_population_control = { type = bool/<type> country = scope }
Supported Scopes: pop pop_group leader species

has_migration_control - Checks if the pop group is prevented from migrating
has_migration_control = { type = bool/<type> country = scope }
Supported Scopes: pop pop_group leader species

has_ascension_perk - Checks if a country has the given ascension perk.
has_ascension_perk = ap_my_ascension_perk
Supported Scopes: country

num_ascension_perks - Compares the number of AP points the country has spent with the given value
num_ascension_perks > 7
Supported Scopes: country

has_military_service_type - Checks if a species/pop group/leader has a particular military service type in their country
has_military_service_type = { country = <who> type = <type> }
Supported Scopes: pop pop_group leader species

has_purge_type - Checks if a species/pop group/leader has a particular purge type in their country
has_purge_type = { country = <who> type = <type> }
Supported Scopes: pop pop_group leader species

has_slavery_type - Checks if a species/pop group/leader has a particular slavery type in their country
has_slavery_type = { country = <who> type = <type> }
Supported Scopes: pop pop_group leader species

has_living_standard - Checks if a species/pop group/leader has a particular living standard in their country
has_living_standard = { country = <who> type = <type> }
Supported Scopes: pop pop_group leader species

has_citizenship_rights - Checks if the pop group/species/leader has rights
has_citizenship_rights = yes/no
Supported Scopes: pop pop_group leader species

num_ascension_perk_slots - Compares the number of unlocked ascension perk slots of the scope with the given value
num_ascension_perks > 7
Supported Scopes: country

is_fleet_idle - Checks if the ship/fleet is idle
is_fleet_idle = yes
Supported Scopes: ship fleet

debug_break - Trigger an assertion to stop the debugger when encountering this trigger; returns the value it is assigned
debug_break = yes
Supported Scopes: all

has_civic - Checks if the current country has the specified civic
has_civic = my_test_civic_1
Supported Scopes: country dlc_recommendation

has_authority - Checks if the current country has the specified government authority
has_authority = auth_democratic
Supported Scopes: country dlc_recommendation

has_invalid_civic - Checks if the current country has a certain civic and if its invalidated
has_invalid_civic = my_test_civic_1
Supported Scopes: country

has_colonization_control - Checks if the pop group is prevented from colonizing
has_colonization_control = { type = bool/<type> country = scope }
Supported Scopes: pop pop_group leader species

planet_garrison_strength - Checks the planet's army strength (as calculated by all armies including offensive or defensive owned by its current controller). Warning: moderately intensive trigger:
planet_garrison_strength >= 510
Supported Scopes: planet

count_species - Counts the number of species in the scope that fulfill the specified criteria, not counting sub-species as unique.
count_species = { count > 4 limit = { <triggers> } }
Supported Scopes: planet country

count_exact_species - Counts the number of species in the scope that fulfill the specified criteria, counting sub-species as unique.
count_exact_species = { count > 4 limit = { <triggers> } }
Supported Scopes: planet country

is_constructing - Checks if the scoped construction ship is building the specified thing
is_constructing = megastructure | <megastructure type> | starbase | mining_station | research_station | observation_post | <ship class>
Supported Scopes: ship fleet

has_secret_fealty_from_subject_of - Checks if the country has a secret fealty from any of the target country's subjects
has_secret_fealty_from_subject_of = <country>
Supported Scopes: country

has_ruler_trait - Checks if a leader has a certain ruler trait, even if they are not currently ruler
has_ruler_trait = leader_trait_carefree
Supported Scopes: leader

num_trait_points - Checks the country/pop group/leader/species' number of traits points spent
num_trait_points < 3
Supported Scopes: country pop pop_group leader species

has_component - Checks if a ship has a certain component
has_component = <component template key>
Supported Scopes: ship ship_growth_stage

has_notification_modifier - Checks if a country has a certain notification modifier
has_notification_modifier = <key>
Supported Scopes: country

pop_maintenance_cost - Checks the maintenance costs of a pop group
pop_maintenance_cost = { value > 0.5/variable resource = energy }
Supported Scopes: pop_group

conditional_tooltip - The enclosed trigger will be completely ignored if the condition in "trigger" isn't true. Useful to hide part of tooltips that are not relevant.
Supported Scopes: all

has_natural_wormhole - Returns true if the scopes system contains at least one natural wormhole
has_natural_wormhole = yes
Supported Scopes: galactic_object

is_astral_rift_pool_empty - Returns true if the astral rift starting event pool is empty
is_astral_rift_pool_empty = yes
Supported Scopes: country

has_astral_rift - Returns true if the scopes system contains at least one astral rift
has_astral_rift = yes
Supported Scopes: galactic_object

has_claim - Checks if the country has claims on the given country or system.
has_claim = <country|system>
Supported Scopes: country

num_active_gateways - Checks the number of active gateways in the galaxy
num_active_gateways < 3
Supported Scopes: all

attacker_war_exhaustion - Checks the war exhaustion of the war's attackers
attacker_war_exhaustion > 0.6
Supported Scopes: war

defender_war_exhaustion - Checks the war exhaustion of the war's defenders
defender_war_exhaustion < 0.2
Supported Scopes: war

off_war_exhaustion_sum - Checks the country's total war exhaustion for all offensive wars
off_war_exhaustion_sum < 0.1
Supported Scopes: country

def_war_exhaustion_sum - Checks the country's total war exhaustion for all defensive wars
def_war_exhaustion_sum > 0.75
Supported Scopes: country

has_starbase_module - Checks if the starbase has a specific module
has_starbase_module = <starbase module>
Supported Scopes: starbase

has_starbase_building - Checks if the starbase has a specific building
has_starbase_building = <starbase building>
Supported Scopes: starbase

has_starbase_size - Compares the starbase ship size
has_starbase_size >= <starbase ship size>
Supported Scopes: starbase

has_seen_any_bypass - Checks the scoped country has ever encountered a bypass of a given type before
has_seen_any_bypass = bypass_type
Supported Scopes: country

has_seen_specific_bypass - Checks the scoped country has encountered a specific bypass before
has_seen_specific_bypass = ROOT
Supported Scopes: country

owns_any_bypass - Checks if the scoped country controls any system containing a bypass of a specific type
owns_any_bypass = bypass_type
Supported Scopes: country

has_casus_belli - Checks if the country has a valid casus belli (any casus belli or a specific one) on the given country.
 has_casus_belli = { 
	target = <country> 
	type = <cb_type> #optional
 }
Supported Scopes: country

num_starbases - Counts the number of starbases owned by the scoped country
num_starbases >= 1
Supported Scopes: country

num_owned_active_gateways - Checks the number of active gateways owned by the scoped country
num_owned_active_gateways < 3
Supported Scopes: country

using_war_goal - Checks if a war has a specific war goal
using_war_goal = { type = <war goal> owner = <eventtarget, country> }
Supported Scopes: war

has_specialist_perk - Checks if the agreement has a specific specialist perk active
has_specialist_perk = <perk_key>
Supported Scopes: agreement

has_active_specialization - Checks if the agreement has an active specialization of the specified type, or of any type if 'any' is specified
has_active_specialization = <specialist_type_key/any>
Supported Scopes: agreement

specialist_tier - Checks the specialization tier of the subject of the agreement.
specialist_tier >=< 2
Supported Scopes: agreement

is_total_war - Checks if a war is a total war
is_total_war = yes/no
Supported Scopes: war

has_status - Checks the current status of the scoped ship or fleet.
has_status = <colossus status> #charging/firing
Supported Scopes: ship fleet

valid_planet_killer_target - Checks if the scoped fleet can target the given planet with its planet killer weapon
valid_planet_killer_target = <planet>
Supported Scopes: fleet

has_secret_fealty_with - Checks if the country has a secret fealty with the other country (in either direction)
has_secret_fealty_with = <country>
Supported Scopes: country

has_orbital_bombardment - Checks whether a planet is under bombardment
has_orbital_bombardment = yes
Supported Scopes: planet

has_orbital_bombardment_stance - Checks to what degree the planet is being bombarded
has_orbital_bombardment_stance = selective
Supported Scopes: planet

count_starbase_sizes - Checks if the scoped country has a specified quantity of a starbase size
count_starbase_sizes = {
	starbase_size = <starbase_ship_size> 
	count >= 2/variable
}
Supported Scopes: country

is_starbase_type - Checks if scoped starbase would evaluate to be a certain starbase_type for its current owner. 
is_starbase_type = sfortress
Supported Scopes: starbase

command_limit - Checks the country's command limit
command_limit > 120
Supported Scopes: country

has_hyperlane_to - Checks if the system has a hyperlane connection to target system
has_hyperlane_to = <target>
Supported Scopes: galactic_object

is_bridge - Checks if a system has the bridge flag or not.
is_bridge = <yes/no>
Supported Scopes: galactic_object

is_capitals_connected_through_relay_network - Checks if current country's capital is connected to target's capital through hyper relay network
is_capitals_connected_through_relay_network = <target>
Supported Scopes: country

is_system_connected_to_relay_network - Checks if target system is connected to own capitals through hyper relay network
is_system_connected_to_relay_network = <target>
Supported Scopes: galactic_object

inverted_switch - Switch case for a trigger treated as NOT.
inverted_switch = {
	trigger = pop_has_ethic
	ethic_xenophile = { <trigger> }
	ethic_xenophobe = { <trigger> }
	default = { <trigger> }
}
Supported Scopes: all

is_scope_set - Checks if the scope is set for appropriate target
is_scope_set = <target>
Supported Scopes: planet country ship pop pop_group fleet

is_primary_star - Checks if the planet is the system's primary star
is_primary_star = yes
Supported Scopes: planet

uses_district_set - Checks if the planet has the specified tag for district usage:
uses_district_set = standard
Supported Scopes: planet

has_climate - Checks if the planet's climate is set to a specified string in planet_classes:
has_climate = dry
Supported Scopes: planet

built_on_planet - Checks if the scoped megastructure is built on a planet
built_on_planet = yes
Supported Scopes: megastructure

last_changed_species_rights_type - Check if the last species rights type changed for the pop group or leader is of type type
last_changed_species_rights_type = <living_standard/citizenship/military_service/slavery/purge/colonization_control/population_control/migration_control/none>
Supported Scopes: pop pop_group leader

controlled_systems - Checks the country's or sector's number of owned systems
controlled_systems < 3
Supported Scopes: country sector

exploitable_planets - Checks the country has planets that are unexploited (i.e. orbital stations can be built on them)
exploitable_planets < 3
Supported Scopes: country

controlled_colonizable - Returns the number of planets within the current country's borders that are habitable but have not been colonized
controlled_colonizable > 0
Supported Scopes: country

ai_colonize_plans - Checks how many plans the AI have for colonization (lighter than controlled_colonizable for AI)
ai_colonize_plans > 0
Supported Scopes: country

ai_terraform_plans - Checks how many plans the AI have for terraforming
ai_terraform_plans > 0
Supported Scopes: country

scientist_count - Checks the country's number of scientists
scientist_count < 4
Supported Scopes: country

has_ai_expansion_plan - Checks if the country AI has any plans to expand
has_ai_expansion_plan = no
Supported Scopes: country

ai_wants_to_negotiate_agreement - Checks if the country AI wants to renegotiate any existing agreements
Supported Scopes: country

is_on_market - Checks if resource is enabled on the Galactic Market
is_on_market = <resource_name>
Supported Scopes: all

can_buy_on_market - Checks if the current country can buy the specified resource on the market or galactic market
can_buy_on_market = <resource_name>
Supported Scopes: country

highest_threat - Checks the country's highest threat against it
highest_threat > 100
Supported Scopes: country

has_rival - Checks if the target country is the country's rival
has_rival = <target>
Supported Scopes: country

has_subject - Checks if the target country is a subject of the current country.
has_subject = <target>
Supported Scopes: country

has_overlord - Checks if the target country is the country's overlord
has_overlord = <target>
Supported Scopes: country

has_any_overlord - Checks if the country has an overlord
has_any_overlord = yes
Supported Scopes: country

has_sector_type - Checks if the sector has a specific type
has_sector_type = <sector type>
Supported Scopes: sector

num_sectors - Counts the number of sectors owned by the scoped country
num_sectors >= 1
Supported Scopes: country

has_deposit_category - Checks if a deposit has specified category
has_deposit_category = <category key>
Supported Scopes: deposit

has_relic - Checks if the scoped country has the specified relic
has_relic = <relic_key>
Supported Scopes: country

caravaneers_enabled - Checks if Caravaneers are enabled in game setup
Supported Scopes: all

lgate_enabled - Checks if L-Gates are enabled in game setup
Supported Scopes: all

num_housing - Checks the planet's total housing
num_housing > 5
Supported Scopes: planet

num_deposits - Checks the planet's total number of deposits
num_deposits > 5
Supported Scopes: planet

is_sector_capital - Checks if the planet is its sector's capital
is_sector_capital = yes
Supported Scopes: planet

is_site_last_die_result - Compares the last dice roll.
is_site_last_die_result >= <int>
Supported Scopes: archaeological_site first_contact astral_rift

is_current_stage_difficulty - Compares the current stage difficulty.
is_current_stage_difficulty >= <int>
Supported Scopes: archaeological_site first_contact astral_rift

is_site_at_stage - Compares the current stage index.
is_site_at_stage >= <int>
Supported Scopes: archaeological_site

is_current_stage_clues - Compares the current stage clues.
is_current_stage_clues >= <int>
Supported Scopes: archaeological_site first_contact

is_site_days_to_next_die_roll - Compares days to next die roll.
is_site_days_to_next_die_roll >= <int>
Supported Scopes: archaeological_site first_contact

is_site_last_excavator - Checks last excavating country.
is_site_last_excavator = <country>
Supported Scopes: archaeological_site

is_site_type - Checks the type of the site.
is_site_type = <archaeological site type key>
Supported Scopes: archaeological_site

is_site_completed - Checks if the site has been completed.
is_site_completed = yes/no
Supported Scopes: archaeological_site first_contact

is_site_under_excavation - Checks if the site is currently being excavated.
is_site_under_excavation = yes/no
Supported Scopes: archaeological_site

is_site_locked - Checks if an archaeological site has progression locked or not.
is_site_locked = yes/no
Supported Scopes: archaeological_site

is_site_current_stage_score - Compares the current stage discovery score.
is_site_current_stage_score >= <int>
Supported Scopes: archaeological_site first_contact astral_rift

is_site_current_stage_score_no_die - Compares the current stage discovery score excluding the current die roll.
is_site_current_stage_score_no_die >= <int>
Supported Scopes: archaeological_site first_contact astral_rift

is_current_excavator_fleet - Checks current excavator fleet.
is_current_excavator_fleet = <fleet>
Supported Scopes: archaeological_site

is_artificial - Checks if the planet is artificial (as set in planet_classes)
is_artificial = yes
Supported Scopes: planet

is_ideal - Checks if the planet is ideal (as set in planet_classes)
is_ideal = yes
Supported Scopes: planet

federation_experience - Checks experience of the federation.
federation_experience >=< 40 );
Supported Scopes: federation

federation_cohesion - Checks cohesion of the federation.
federation_cohesion >=< 40 );
Supported Scopes: federation

federation_cohesion_growth - Checks cohesion growth of the federation.
federation_cohesion_growth >=< 40 );
Supported Scopes: federation

has_any_federation_law_in_category - Checks if given law category has any active law
has_any_federation_law_in_category = <federation law category>
Supported Scopes: federation

has_federation_law - Checks if given law has been enacted in scoped federation
has_federation_law = <federation law>
Supported Scopes: federation

has_federation_perk - Checks if given perk has been unlocked in scoped federation
has_federation_perk = <federation perk>
Supported Scopes: federation

has_federation_type - Checks if federation has specific federation type
has_federation_type = <federation type>
Supported Scopes: federation

federation_level - Checks federation level in comparison to given value in scoped federation
federation_level >=< <federation level>
Supported Scopes: federation

is_voting_on_resolution - Checks if the Galactic Community is currently voting on any, or a specific, resolution
is_voting_on_resolution = <resolution/any>
Supported Scopes: all

is_proposing_resolution - Checks if the scoped country is currently proposing any, or a specific, resolution
is_proposing_resolution = <resolution/any>
Supported Scopes: country

last_resolution_changed - Checks if the last resolution the Galactic Community voted on or otherwise passed or failed is as specified.
last_resolution_changed = <resolution>
Supported Scopes: all

last_resolution_category_changed - Checks if the last resolution the Galactic Community voted on or otherwise passed or failed is part of the specified category.
last_resolution_category_changed = <resolution_category>
Supported Scopes: all

position_on_current_resolution - Checks if the current country is supporting, opposing or abstaining from the currently proposed galcom resolution.
position_on_current_resolution = support/oppose/abstain
Supported Scopes: country

position_on_last_resolution - Checks if the current country was supporting, opposing or abstaining from the last proposed galcom resolution.
position_on_last_resolution = support/oppose/abstain
Supported Scopes: country

is_years_since_community_formation - Compare with number of years since the formation of the Galactic Community. NOTE: A negative value means it hasn't been formed yet!
is_years_since_community_formationn >= <int32>
Supported Scopes: all

is_years_since_council_establishment - Compares with number of years since the establishment of the Galactic Council. NOTE: A negative value means it hasn't been established yet!
is_years_since_council_establishment >= <int32>
Supported Scopes: all

is_galactic_community_formed - Checks if the Galactic Community has been formed
is_galactic_community_formed = yes/no
Supported Scopes: all

is_galactic_council_established - Checks if the Galactic Council has been established
is_galactic_council_established = yes/no
Supported Scopes: all

is_galactic_community_member - Checks if scoped country is part of the Galactic Community
is_galactic_community_member = yes/no
Supported Scopes: country

is_part_of_galactic_council - Checks if scoped country is part of the Galactic Council
is_part_of_galactic_council = yes/no
Supported Scopes: country

num_members - Checks number of members in scoped federation
num_members >=< <integer value>
Supported Scopes: federation

num_associates - Checks number of associates in scoped federation
num_associates >=< <integer value>
Supported Scopes: federation

has_origin - Checks if scoped country has specified origin
has_origin = <origin key>
Supported Scopes: country dlc_recommendation

is_last_lost_relic - Checks whether the relic passed in parameter is the last relic lost by the country int the current scope.
is_last_lost_relic = <relic_key>
Supported Scopes: country

is_last_received_relic - Checks whether the relic passed in parameter is the last relic received by the country int the current scope.
is_last_received_relic = <relic_key>
Supported Scopes: country

is_active_resolution - Checks if the provided Resolution is active in the Community
is_active_resolution = <resolution_type_key>
Supported Scopes: all

is_in_breach_of_any - Checks if an empire is in breach of any galactic resolution.
is_in_breach_of_any = yes/no
Supported Scopes: country

in_breach_of - Checks if the scoped country is in breach of the specified resolution (or would be, were it to be enacted)
in_breach_of = <resolution>
Supported Scopes: country

num_council_positions - Compares the number of council positions in the Galactic Community.
num_council_positions >= <int32>
Supported Scopes: all

galactic_community_rank - Compares empire rank ( sorted by diplomatic weight ) in the Galactic Community. NOTE: If the scoped country isn't part of the community this returns -1.
galactic_community_rank >= <int32>
Supported Scopes: country

is_permanent_councillor - Checks if an empire has a permanent seat on the Galactic Council
is_permanent_councillor = yes/no
Supported Scopes: country

is_councilor - Checks if scoped leader is a member of the Empire Council or the Ruler
is_councilor = yes/no
Supported Scopes: leader

has_federation_setting - Checks if given setting is on for scoped federation
has_federation_setting = <setting>
Supported Scopes: federation

num_ai_empires_setting - Checks the number of AI empires defined in setup
num_ai_empires_setting >= 1
Supported Scopes: all

num_defensive_pacts - Checks the number of defensive pacts the current country has.
num_defensive_pacts > 2
Supported Scopes: country

num_support_independence - Checks the number of empires the current country is supporting the independence of.
num_support_independence > 2
Supported Scopes: country

num_guarantees - Checks the number of empires the current country is guaranteeing.
num_guarantees > 2
Supported Scopes: country

num_non_aggression_pacts - Checks the number of non-aggression pacts the current country has.
num_non_aggression_pacts > 2
Supported Scopes: country

num_commercial_pacts - Checks the number of commercial pacts the current country has.
num_commercial_pacts > 2
Supported Scopes: country

num_research_agreements - Checks the number of research agreements a country has
num_research_agreements > 2
Supported Scopes: country

num_migration_pacts - Checks the number of migration pacts a country has
num_migration_pacts > 2
Supported Scopes: country

num_rivals - Checks the number of rivalries a country has
num_rivals > 2
Supported Scopes: country

num_closed_borders - Checks the number of countries the country has closed borders to
num_closed_borders > 2
Supported Scopes: country

num_truces - Checks the number of truces country has
num_truces > 2
Supported Scopes: country

galaxy_size - Checks whether the galaxy size if of a certain type
galaxy_size=medium
Supported Scopes: all

galaxy_shape - Checks whether the galaxy shape if of a certain shape
galaxy_shape = spiral_2
Supported Scopes: all

pop_has_happiness - Checks if the current pop has happiness or not.
pop_has_happiness = yes/no
Supported Scopes: pop pop_group

pop_group_has_happiness - Checks if the current pop group has happiness or not.
pop_group_has_happiness = yes/no
Supported Scopes: pop_group

pop_group_size - Checks if the size of the pop group is according to the argument.
pop_group_size > 8
Supported Scopes: pop_group

has_current_purge - Checks if any pops are being purged on the current planet.
has_current_purge = yes/no
Supported Scopes: planet

species_has_happiness_with_owner - Checks if the current species has happiness or not when owned by a specified country.
species_has_happiness_with_owner = country
Supported Scopes: species

num_planets_in_system - Checks the solar system's total number of planets
num_planets_in_system > 5
Supported Scopes: galactic_object

num_galaxy_systems - Checks number of star systems in the galaxy
num_galaxy_systems > 400
Supported Scopes: all

num_assigned_jobs - Checks the number of pops the planet or country has that work a specific job.
num_assigned_jobs = { job = <key> value > 201 }
Supported Scopes: planet country

has_active_first_contact_with - Checks if the scoped country has an active First Contact site with the target country
has_active_first_contact_with = <country>
Supported Scopes: country

can_have_first_contact_site_with - Checks if the scoped country is allowed to have a First Contact site with the target country
can_have_first_contact_site_with = <country>
Supported Scopes: country

is_current_first_contact_stage - Checks if the scoped first contact is at the specified stage.
is_current_first_contact_stage = default_stage_2
Supported Scopes: first_contact

has_spynetwork - Checks if scoped country has any spynetworks with a value > 0
has_spynetwork = yes
Supported Scopes: country

has_espionage_asset - Checks if the scope hold an asset of specified type
has_espionage_asset = <asset type>
Supported Scopes: spy_network espionage_operation

has_espionage_operation_flag - Checks if the espionage operation has a specific flag
has_espionage_operation_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_operation

has_crisis_perk - Checks if a country has a specific Crisis Perk unlocked.
has_crisis_perk = <crisis_perk_name>
Supported Scopes: country

has_menace_perk - Checks if a country has a specific Menace Perk unlocked.
has_menace_perk = <crisis_perk_name>
Supported Scopes: country

organic_pops_last_month_growth - Checks how many organic pops the planet gained last month (through growth and assembly).
organic_pops_last_month_growth > 4
Supported Scopes: planet

artificial_pops_last_month_growth - Checks how many artificial pops the planet assembled last month.
artificial_pops_last_month_growth > 4
Supported Scopes: planet

has_spy_power - Compares the infiltration level of the network
has_spy_power = <num>
Supported Scopes: spy_network

has_available_spy_power - Compares the available infiltration level of the network
has_available_spy_power = <num>
Supported Scopes: spy_network

has_espionage_category - Checks if the scope is of a specific category
has_espionage_category = <espionage category key>
Supported Scopes: espionage_operation

is_running_espionage_operation - Checks if the scope is currently running an espionage operation
is_running_espionage_operation = <bool>
Supported Scopes: country spy_network

has_espionage_type - Checks if the scope is of a specific type
has_espionage_type = <espionage type key>
Supported Scopes: espionage_operation

relative_encryption_decryption - Divides the encryption value of the scope object with the decryption value of the target and compares with value. Target is only used for country scope.
relative_encryption_decryption = {
	target = <country>
	value > 1.0/variable
}
Supported Scopes: country spy_network espionage_operation

is_espionage_operation_days_to_next_die_roll - Compares days to next die roll.
is_espionage_operation_days_to_next_die_roll >= <value>
Supported Scopes: espionage_operation

is_espionage_operation_chapter - Compares the current espionage operation chapter index.
is_espionage_operation_chapter >= <int>
Supported Scopes: espionage_operation

is_espionage_operation_difficulty - Compares the espionage operation difficulty.
is_espionage_operation_difficulty >= <value>
Supported Scopes: espionage_operation

is_espionage_operation_score_no_die - Compares the current espionage score excluding the current die roll.
is_espionage_operation_score_no_die >= <value>
Supported Scopes: espionage_operation

is_espionage_operation_score - Compares the current espionage score.
is_espionage_operation_score >= <value>
Supported Scopes: espionage_operation

is_espionage_operation_last_die_result - Compares the last dice roll.
is_espionage_operation_last_die_result >= <int>
Supported Scopes: espionage_operation

is_espionage_operation_auto_accept_events - Checks if scoped espionage operation accepts events automatically when they are ready
is_espionage_operation_auto_accept_events = <bool>
Supported Scopes: espionage_operation

num_espionage_assets - Compares the number of assets associated with the scope object.
num_espionage_assets = <int>
Supported Scopes: spy_network espionage_operation

has_ship_owner_type - Checks if the ship/fleet/design/growth stage has a specific owner type (country/federation/galactic_community/global_ship_design)
has_ship_owner_type = galactic_community
Supported Scopes: ship fleet design ship_growth_stage

has_crisis_level - Checks if a country has a specific Crisis Level unlocked.
has_crisis_level = <crisis_level_name>
Supported Scopes: country

has_spynetwork_value - Compares spy network value of the scoped object
has_spynetwork_value >= <value>
Supported Scopes: spy_network

is_spynetwork_level - Compares spy network level of the scoped object
is_spynetwork_level >= <int>
Supported Scopes: spy_network

is_counter_espionage - Compares counter espionage of the scoped object
is_counter_espionage >= <value>
Supported Scopes: country

has_embassy - Check if the country has an embassy with the target country
has_embassy = <target>
Supported Scopes: country

is_spynetwork_max_level - Compares spy network max level of the scoped object
is_spynetwork_max_level >= <int>
Supported Scopes: spy_network

is_starbase_building_module - Checks if the starbase is currently building a specific module
is_starbase_building_module = <starbase module>
Supported Scopes: starbase

is_starbase_building_building - Checks if the starbase is currently building a specific building
is_starbase_building_building = <starbase building>
Supported Scopes: starbase

starbase_buildable_is_in_queue_before - Check if the first buildable is in the starbase building queue before the second buildable (for prerequisites, mostly)
Returns false if the first one, or both aren't in the queue. Returns true if the first one is in, but the second isn't.
starbase_buildable_is_in_queue_before = { first = <buildable> second = <buildable>
Supported Scopes: starbase

has_job_category - Checks if the job has a specific category set.
has_job_category = <key>
Supported Scopes: pop job

has_term_value - Checks if the agreement has a specific term
has_term_value = { term = <term> value = <term_value> }
Supported Scopes: agreement

is_action_active - Check if a trade action is already active in a trade deal with the specified empire (or with any empire if so specified)
is_action_active = { action = <action_key> with_country = <other_country_scope/any> }
Supported Scopes: country

is_offer_terms_actual - Checks if terms of the special offer between scoped and target countries is not obsolete
Only works in certain parts of the script marked with ai_trade_facility.
is_offer_terms_actual = { target = <country> } 
Supported Scopes: country

can_afford_special_offer - Checks if the scoped country can afford the offer given by the target country. Only works in certain parts of the script marked with ai_trade_facility.
can_afford_special_offer = { target = <country> } 
Supported Scopes: country

has_design_flag - Checks if the design has a specific flag
has_design_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: design

enclave_capacity_left - Checks the country's free enclave number capacity in absolute numbers
enclave_capacity_left > 1
Supported Scopes: country

is_cloaked - Checks if a fleet or ship is cloaked.
is_cloaked = <yes/no>
Supported Scopes: ship fleet

has_cloaking_strength - Compares cloaking strength value of the scoped fleet or ship.
has_cloaking_strength >= <value>
Supported Scopes: ship fleet

has_cloaking_detection - Compares cloaking detection value of the scoped fleet or ship.
has_cloaking_detection >= <value>
Supported Scopes: ship fleet

has_awareness - Checks the country's awareness if it's pre-FTL
has_awareness < 90
Supported Scopes: country

current_awareness_level - Checks the country's awareness level if it's pre-FTL
current_awareness_level > none/low/medium/high/full
Supported Scopes: country

has_next_pre_ftl_age - Checks if the country is a pre-FTL civilization and has another pre-FTL tech age after its current one 
has_next_pre_ftl_age = yes
Supported Scopes: country

has_pre_ftl_age - Checks if the country is a pre-FTL civilization and is in the specified age 
has_pre_ftl_age = <age_key>
Supported Scopes: country

triumph_days_left - Checks the number of days left for the Relics Triumph
triumph_days_left > 900
Supported Scopes: country

astral_rift_relative_difficulty - Checks the difference between an explorer's level and an Astral Rift current difficulty
astral_rift_relative_difficulty ><= <int>
Supported Scopes: astral_rift

is_garrison - Checks if the scoped fleet is a garrison.
is_garrison = yes / no
Supported Scopes: fleet

num_positive_traits - Checks the country/pop/leader/species' number of positive traits (traits with a cost strictly greater than 0 count as positive)
num_positive_traits < 3
Supported Scopes: country pop pop_group leader species

num_negative_traits - Checks the country/pop/leader/species' number of negative traits (traits with a cost strictly lower than 0 count as negative)
num_negative_traits < 3
Supported Scopes: country pop pop_group leader species

is_on_galaxy_map - Checks if the current player is currently viewing the galaxy map.
Supported Scopes: planet country ship pop pop_group fleet

is_paused - Checks if the current player is currently paused.
Supported Scopes: planet country ship pop pop_group fleet

astral_rifts_completed - Return how many Astral Rifts were completed by the country
astral_rifts_completed ><= <int>
Supported Scopes: country

is_astral_rift_explored - Returns true if the astral rift with the given id is or was explored by the scoped country
is_astral_rift_explored = <rift_id>
Supported Scopes: country

is_bypass_type - Returns true if the scope bypass is of type <type>
is_bypass_type = <type>
Supported Scopes: bypass

has_lock - Returns true if the bypass is locked by a dimensional lock
has_lock = yes
Supported Scopes: bypass

can_go_mia - Checks if the scoped fleet can go MIA.
can_go_mia = yes / no
Supported Scopes: fleet

is_on_slave_market - Checks if any pops from the scoped pop group are being sold on the slave market:
is_on_slave_market = yes/no
Supported Scopes: pop pop_group

num_cosmic_storms - Checks the amount of currently active cosmic storms.
Supported Scopes: all

timed_flag_days_left - Checks the scoped object for the remaining days left of the specified timed flag
timed_flag_days_left = { flag = <flag> value > 30 }
(note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector no_scope archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

has_asteroid_belt - Returns true if the scoped galactic object has an asteroid belt.
has_asteroid_belt = yes/no
Supported Scopes: galactic_object

cosmic_storm_system_influence - Checks the systems total cosmic storm influence
Supported Scopes: galactic_object

is_last_acquired_specimen - Checks if the specified specimen was the last acquired one 
last_acquired_specimen = <specimen>
Supported Scopes: country

can_give_specimen - Checks if can give a specific specimen. Checks if specimen is already given and if there is an available exhibit slot
can_give_specimen = <specimen>
Supported Scopes: country

is_influence_center - Checks if the planet is colonized (in planet scope) or the system has an owner (in system scope)
has_owner = yes
Supported Scopes: galactic_object

has_storm_flag - Checks if the cosmic storm has a specific flag
has_storm_flag = <flag> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: cosmic_storm

num_asteroid_belts - Checks the system's number of asteroid belts
num_asteroid_belts > 1
Supported Scopes: galactic_object

has_environmental_effects - Checks if a star system has any environmental effects
Supported Scopes: galactic_object

num_cosmic_storms_encountered - Returns the amount of all storms the country was affected by. Storms that leave stop affecting the country to return to it later are counted as multiple
Supported Scopes: country

num_unique_cosmic_storms_encountered - Returns the amount of all unique storms the country was affected by. Storms that leave stop affecting the country to return to it later are counted as one
Supported Scopes: country

num_storm_exploitation_buildings - Checks the number of cosmic storm exploitation buildings with positive effects on a country
Supported Scopes: planet country

is_storm_active_in_storm_sector - Checks if there is currently a storm active within the storm sector that this system belongs to. The galaxy is split up in multiple storm sectors, which we use to avoid spawning storms too close to each other.
Supported Scopes: galactic_object

num_cosmic_storm_early_game_spawn_chance_scale_setting - Checks the spawn storm chance scale in early game for cosmic storms
Supported Scopes: all

num_cosmic_storm_mid_game_spawn_chance_scale_setting - Checks the spawn storm chance scale in mid game for cosmic storms
Supported Scopes: all

num_cosmic_storm_late_game_spawn_chance_scale_setting - Checks the spawn storm chance scale in late game for cosmic storms
Supported Scopes: all

num_cosmic_storm_early_game_spawn_max_cap_setting - Checks the spawn storm max cap in early game for cosmic storms
Supported Scopes: all

num_cosmic_storm_mid_game_spawn_max_cap_setting - Checks the spawn storm max cap in mid game for cosmic storms
Supported Scopes: all

num_cosmic_storm_late_game_spawn_max_cap_setting - Checks the spawn storm max cap in late game for cosmic storms
Supported Scopes: all

num_cosmic_storm_spawn_cooldown_scale_setting - Checks the spawn storm cooldown scale for cosmic storms
Supported Scopes: all

is_storm_type - Checks if the scoped Cosmic Storm's type is equal to <type>
is_storm_type = <type>
Supported Scopes: cosmic_storm

ship_size_multiplier - Compares ship size multiplier of the scoped design or ship.
get_ship_size_multiplier >= <value>
Supported Scopes: ship ship_growth_stage

is_exhibit_active - Check if the scoped exhibit is active
is_exhibit_active = <yes/no>
Supported Scopes: exhibit

num_vivarium_slots - Returns the country's used Vivarium slots
num_vivarium_slots > 0
Supported Scopes: country

has_specimen - Checks if the scoped country has the specified specimen
has_specimen = <specimen_key/exhibit>
Supported Scopes: country

is_space_fauna - Checks if the scoped fleet or ship is space fauna (as set in ship sizes).
is_space_fauna = <yes/no>
Supported Scopes: ship fleet design ship_growth_stage

can_be_reanimated - Checks if the ship/design can be reanimated.
can_be_reanimated = yes / no
Supported Scopes: ship ship_growth_stage

is_ship_category - Checks if the ship/fleet/design is a specific ship category
is_ship_category = <key>
Supported Scopes: ship fleet ship_growth_stage

is_specimen_rarity - Checks if the specified specimen contained by the scoped exhibit is of indicated rarity
is_specimen_rarity = <rarity>
Supported Scopes: exhibit

is_specimen_category - Checks if the specified specimen contained by the scoped exhibit is of indicated collection category
is_specimen_category = <specimen_type>
Supported Scopes: exhibit

count_used_naval_cap - Checks used naval cap by the scoped country or fleet's controlled ships which fulfill the specified criteria.
count_used_naval_cap = { limit = { <triggers> } count < 6 }
Supported Scopes: country fleet

ship_size_cost_resource_percent - Retrieves the percentage of usage of a given resource in the ship size. If the ship size cost is 100 food and 300 minerals, the value when checking for food is 0.25
ship_size_cost_resource_percent = <resource_key>
Supported Scopes: ship ship_growth_stage

has_dna - Check if dna has been acquired for the given category
has_dna = { ship_category = <key> rarity=<key> (optional) }
Supported Scopes: country

is_last_acquired_specimen_rarity - Checks if the last acquired specimen is of the given rarity
is_last_acquired_specimen_rarity = <rarity>
Supported Scopes: country

trait_has_all_tags - Checks if a trait has all tags in the list 
trait_has_all_tags = { biological lithoids }
Supported Scopes: trait

trait_has_any_tag - Checks if a trait has at least one tag from the list 
trait_has_any_tag = { biological lithoids }
Supported Scopes: trait

uses_ship_category - Checks if the graphical culture used by the scoped country allows for usage of a given ship category
uses_ship_category = <category>
Supported Scopes: country

is_last_acquired_specimen_from_trade - Checks if the last acquired specimen was acquired through a trade deal
is_last_acquired_specimen_from_trade = <yes/no>
Supported Scopes: country

is_default_species - checks if the scoped country has the target species set a default for its species group.
is_default_species = <target>
Supported Scopes: country

is_being_integrated_by - Checks if a species has a particular species right that enabled sub-species integration
is_being_integrated_by = <country>
Supported Scopes: species

has_active_focus - Checks if a country has a particular focus card active active
has_active_focus = <focus_card_key>
Supported Scopes: country

has_completed_focus - Checks if a country has a particular focus card completed
has_completed_focus = <focus_card_key>
Supported Scopes: country

num_zones - Checks the number the planet has of any, or a specific, zone
num_zones = { type = <key/any> value > 2/variable }
Supported Scopes: planet country

bioship_can_grow - Checks if the bioship can get growth progress.
bioship_can_grow = yes / no
Supported Scopes: ship

num_pops_with_job_tag - Checks how many pops that has jobs with all given tags in a planet 
num_pops_with_job_tag = { tags = { farmer trader } value = 1000 }
Supported Scopes: planet

num_country_pops_with_job_tag - Checks how many pops that has jobs with all given tags in a country 
num_country_pops_with_job_tag = { tags = { farmer trader } value = 1000 }
Supported Scopes: country

any_agreement - Iterate through each agreement - checks whether the enclosed triggers return true for any of them
any_agreement = { <triggers> }
Supported Scopes: country no_scope

count_agreement - Iterate through each agreement - checks whether the enclosed triggers return true for X/all of them
count_agreement = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country no_scope

any_ambient_object - Iterate through every ambient object in the game - checks whether the enclosed triggers return true for any of them
any_ambient_object = { <triggers> }
Supported Scopes: all

count_ambient_object - Iterate through every ambient object in the game - checks whether the enclosed triggers return true for X/all of them
count_ambient_object = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_system_ambient_object - Iterate through every ambient object in the solar system - checks whether the enclosed triggers return true for any of them
any_system_ambient_object = { <triggers> }
Supported Scopes: galactic_object

count_system_ambient_object - Iterate through every ambient object in the solar system - checks whether the enclosed triggers return true for X/all of them
count_system_ambient_object = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_archaeological_site - Iterate through every archaeological sites - checks whether the enclosed triggers return true for any of them
any_archaeological_site = { <triggers> }
Supported Scopes: all

count_archaeological_site - Iterate through every archaeological sites - checks whether the enclosed triggers return true for X/all of them
count_archaeological_site = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_owned_army - Iterate through each army that is owned by the country - checks whether the enclosed triggers return true for any of them
any_owned_army = { <triggers> }
Supported Scopes: country

count_owned_army - Iterate through each army that is owned by the country - checks whether the enclosed triggers return true for X/all of them
count_owned_army = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - checks whether the enclosed triggers return true for any of them
any_planet_army = { <triggers> }
Supported Scopes: planet

count_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - checks whether the enclosed triggers return true for X/all of them
count_planet_army = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - checks whether the enclosed triggers return true for any of them
any_ground_combat_defender = { <triggers> }
Supported Scopes: planet

count_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - checks whether the enclosed triggers return true for X/all of them
count_ground_combat_defender = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - checks whether the enclosed triggers return true for any of them
any_ground_combat_attacker = { <triggers> }
Supported Scopes: planet

count_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - checks whether the enclosed triggers return true for X/all of them
count_ground_combat_attacker = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_astral_rift - Iterate through every astral rift - checks whether the enclosed triggers return true for any of them
any_astral_rift = { <triggers> }
Supported Scopes: all

count_astral_rift - Iterate through every astral rift - checks whether the enclosed triggers return true for X/all of them
count_astral_rift = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_bypass - Iterate through every bypass - checks whether the enclosed triggers return true for any of them
any_bypass = { <triggers> }
Supported Scopes: all

count_bypass - Iterate through every bypass - checks whether the enclosed triggers return true for X/all of them
count_bypass = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_bypass_in_system - Iterate through every bypass in the scoped galactic object. - checks whether the enclosed triggers return true for any of them
any_bypass_in_system = { <triggers> }
Supported Scopes: galactic_object

count_bypass_in_system - Iterate through every bypass in the scoped galactic object. - checks whether the enclosed triggers return true for X/all of them
count_bypass_in_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_cosmic_storm - Iterate through all cosmic storms in the galaxy - checks whether the enclosed triggers return true for any of them
any_cosmic_storm = { <triggers> }
Supported Scopes: all

count_cosmic_storm - Iterate through all cosmic storms in the galaxy - checks whether the enclosed triggers return true for X/all of them
count_cosmic_storm = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_system_within_storm - Iterate through all systems within the storm - checks whether the enclosed triggers return true for any of them
any_system_within_storm = { <triggers> }
Supported Scopes: cosmic_storm

count_system_within_storm - Iterate through all systems within the storm - checks whether the enclosed triggers return true for X/all of them
count_system_within_storm = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: cosmic_storm

any_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - checks whether the enclosed triggers return true for any of them
any_cosmic_storm_start_position = { <triggers> }
Supported Scopes: all

count_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - checks whether the enclosed triggers return true for X/all of them
count_cosmic_storm_start_position = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - checks whether the enclosed triggers return true for any of them
any_cosmic_storm_end_position = { <triggers> }
Supported Scopes: all

count_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - checks whether the enclosed triggers return true for X/all of them
count_cosmic_storm_end_position = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_system_added_to_storm - Iterate through all systems added to the storm - checks whether the enclosed triggers return true for any of them
any_system_added_to_storm = { <triggers> }
Supported Scopes: cosmic_storm

count_system_added_to_storm - Iterate through all systems added to the storm - checks whether the enclosed triggers return true for X/all of them
count_system_added_to_storm = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: cosmic_storm

any_system_removed_from_storm - Iterate through all systems removed from storm - checks whether the enclosed triggers return true for any of them
any_system_removed_from_storm = { <triggers> }
Supported Scopes: cosmic_storm

count_system_removed_from_storm - Iterate through all systems removed from storm - checks whether the enclosed triggers return true for X/all of them
count_system_removed_from_storm = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: cosmic_storm

any_owned_storm_influence_field - Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for any of them
any_owned_storm_influence_field = { <triggers> }
Supported Scopes: country

count_owned_storm_influence_field - Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for X/all of them
count_owned_storm_influence_field = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for any of them
any_system_in_cosmic_storm_influence_field = { <triggers> }
Supported Scopes: cosmic_storm_influence_field

count_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for X/all of them
count_system_in_cosmic_storm_influence_field = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: cosmic_storm_influence_field

any_country - Iterate through all countries - checks whether the enclosed triggers return true for any of them
any_country = { <triggers> }
Supported Scopes: all

count_country - Iterate through all countries - checks whether the enclosed triggers return true for X/all of them
count_country = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_relation - Iterate through all relations - checks whether the enclosed triggers return true for any of them
any_relation = { <triggers> }
Supported Scopes: country

count_relation - Iterate through all relations - checks whether the enclosed triggers return true for X/all of them
count_relation = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_neighbor_country - Iterate through all neighbor countries - checks whether the enclosed triggers return true for any of them
any_neighbor_country = { <triggers> }
Supported Scopes: country

count_neighbor_country - Iterate through all neighbor countries - checks whether the enclosed triggers return true for X/all of them
count_neighbor_country = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - checks whether the enclosed triggers return true for any of them
any_country_neighbor_to_system = { <triggers> }
Supported Scopes: galactic_object

count_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - checks whether the enclosed triggers return true for X/all of them
count_country_neighbor_to_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_rival_country - Iterate through all countries rivalled by the scoped country - checks whether the enclosed triggers return true for any of them
any_rival_country = { <triggers> }
Supported Scopes: country

count_rival_country - Iterate through all countries rivalled by the scoped country - checks whether the enclosed triggers return true for X/all of them
count_rival_country = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_federation_ally - Iterate through all countries in a federation with the scoped country - checks whether the enclosed triggers return true for any of them
any_federation_ally = { <triggers> }
Supported Scopes: country

count_federation_ally - Iterate through all countries in a federation with the scoped country - checks whether the enclosed triggers return true for X/all of them
count_federation_ally = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_playable_country - Iterate through all playable countries - checks whether the enclosed triggers return true for any of them
any_playable_country = { <triggers> }
Supported Scopes: all

count_playable_country - Iterate through all playable countries - checks whether the enclosed triggers return true for X/all of them
count_playable_country = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_subject - Iterate through all subjects of the scoped country - checks whether the enclosed triggers return true for any of them
any_subject = { <triggers> }
Supported Scopes: country

count_subject - Iterate through all subjects of the scoped country - checks whether the enclosed triggers return true for X/all of them
count_subject = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_available_debris - Iterate through all debris belong to available special projects of the scoped country - checks whether the enclosed triggers return true for any of them
any_available_debris = { <triggers> }
Supported Scopes: country

count_available_debris - Iterate through all debris belong to available special projects of the scoped country - checks whether the enclosed triggers return true for X/all of them
count_available_debris = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
any_pre_ftl_within_border = { <triggers> }
Supported Scopes: country sector

count_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
count_pre_ftl_within_border = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country sector

any_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
any_observed_pre_ftl_within_border = { <triggers> }
Supported Scopes: country sector

count_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
count_observed_pre_ftl_within_border = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country sector

any_owned_design - Iterate through all designs owned by the current country - checks whether the enclosed triggers return true for any of them
any_owned_design = { <triggers> }
Supported Scopes: country

count_owned_design - Iterate through all designs owned by the current country - checks whether the enclosed triggers return true for X/all of them
count_owned_design = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_spynetwork - Iterate through each spynetwork - checks whether the enclosed triggers return true for any of them
any_spynetwork = { <triggers> }
Supported Scopes: country no_scope

count_spynetwork - Iterate through each spynetwork - checks whether the enclosed triggers return true for X/all of them
count_spynetwork = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country no_scope

any_espionage_operation - Iterate through each espionage operation - checks whether the enclosed triggers return true for any of them
any_espionage_operation = { <triggers> }
Supported Scopes: country no_scope spy_network

count_espionage_operation - Iterate through each espionage operation - checks whether the enclosed triggers return true for X/all of them
count_espionage_operation = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country no_scope spy_network

any_espionage_asset - Iterate through each espionage asset - checks whether the enclosed triggers return true for any of them
any_espionage_asset = { <triggers> }
Supported Scopes: no_scope spy_network espionage_operation

count_espionage_asset - Iterate through each espionage asset - checks whether the enclosed triggers return true for X/all of them
count_espionage_asset = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: no_scope spy_network espionage_operation

any_exhibit - Iterate through every exhibit - checks whether the enclosed triggers return true for any of them
any_exhibit = { <triggers> }
Supported Scopes: country

count_exhibit - Iterate through every exhibit - checks whether the enclosed triggers return true for X/all of them
count_exhibit = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_federation - Iterate through each federation - checks whether the enclosed triggers return true for any of them
any_federation = { <triggers> }
Supported Scopes: all

count_federation - Iterate through each federation - checks whether the enclosed triggers return true for X/all of them
count_federation = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - checks whether the enclosed triggers return true for any of them
any_first_contact = { <triggers> }
Supported Scopes: country

count_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - checks whether the enclosed triggers return true for X/all of them
count_first_contact = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - checks whether the enclosed triggers return true for any of them
any_active_first_contact = { <triggers> }
Supported Scopes: country

count_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - checks whether the enclosed triggers return true for X/all of them
count_active_first_contact = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_galaxy_fleet - Iterate through each fleet in the entire game - checks whether the enclosed triggers return true for any of them
any_galaxy_fleet = { <triggers> }
Supported Scopes: all

count_galaxy_fleet - Iterate through each fleet in the entire game - checks whether the enclosed triggers return true for X/all of them
count_galaxy_fleet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_combatant_fleet - Iterate through each fleet this fleet is in combat with - checks whether the enclosed triggers return true for any of them
any_combatant_fleet = { <triggers> }
Supported Scopes: fleet

count_combatant_fleet - Iterate through each fleet this fleet is in combat with - checks whether the enclosed triggers return true for X/all of them
count_combatant_fleet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: fleet

any_fleet_in_system - Iterate through each fleet in the current system - checks whether the enclosed triggers return true for any of them
any_fleet_in_system = { <triggers> }
Supported Scopes: galactic_object

count_fleet_in_system - Iterate through each fleet in the current system - checks whether the enclosed triggers return true for X/all of them
count_fleet_in_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_owned_fleet - Iterate through each fleet owned by the country - checks whether the enclosed triggers return true for any of them
any_owned_fleet = { <triggers> }
Supported Scopes: country

count_owned_fleet - Iterate through each fleet owned by the country - checks whether the enclosed triggers return true for X/all of them
count_owned_fleet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_controlled_fleet - Iterate through each fleet controlled by the country - checks whether the enclosed triggers return true for any of them
any_controlled_fleet = { <triggers> }
Supported Scopes: country

count_controlled_fleet - Iterate through each fleet controlled by the country - checks whether the enclosed triggers return true for X/all of them
count_controlled_fleet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - checks whether the enclosed triggers return true for any of them
any_fleet_in_orbit = { <triggers> }
Supported Scopes: megastructure planet starbase

count_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - checks whether the enclosed triggers return true for X/all of them
count_fleet_in_orbit = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: megastructure planet starbase

any_orbital_station - Iterate through each orbital station owned by the current country or in the current system - checks whether the enclosed triggers return true for any of them
any_orbital_station = { <triggers> }
Supported Scopes: country galactic_object

count_orbital_station - Iterate through each orbital station owned by the current country or in the current system - checks whether the enclosed triggers return true for X/all of them
count_orbital_station = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country galactic_object

any_galcom_member - Iterate through each member of the galactic community - checks whether the enclosed triggers return true for any of them
any_galcom_member = { <triggers> }
Supported Scopes: all

count_galcom_member - Iterate through each member of the galactic community - checks whether the enclosed triggers return true for X/all of them
count_galcom_member = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_council_member - Iterate through each member of the galactic council - checks whether the enclosed triggers return true for any of them
any_council_member = { <triggers> }
Supported Scopes: all

count_council_member - Iterate through each member of the galactic council - checks whether the enclosed triggers return true for X/all of them
count_council_member = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_owned_leader - Iterate through each leader that is owned by the country - checks whether the enclosed triggers return true for any of them
any_owned_leader = { <triggers> }
Supported Scopes: country

count_owned_leader - Iterate through each leader that is owned by the country - checks whether the enclosed triggers return true for X/all of them
count_owned_leader = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_pool_leader - Iterate through each leader that is recruitable for the country - checks whether the enclosed triggers return true for any of them
any_pool_leader = { <triggers> }
Supported Scopes: country

count_pool_leader - Iterate through each leader that is recruitable for the country - checks whether the enclosed triggers return true for X/all of them
count_pool_leader = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_envoy - Iterate through each envoy available to the country - checks whether the enclosed triggers return true for any of them
any_envoy = { <triggers> }
Supported Scopes: country

count_envoy - Iterate through each envoy available to the country - checks whether the enclosed triggers return true for X/all of them
count_envoy = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_megastructure - Iterate through each megastructure - checks whether the enclosed triggers return true for any of them
any_megastructure = { <triggers> }
Supported Scopes: all

count_megastructure - Iterate through each megastructure - checks whether the enclosed triggers return true for X/all of them
count_megastructure = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_owned_megastructure - Iterate through each owned megastructure - checks whether the enclosed triggers return true for any of them
any_owned_megastructure = { <triggers> }
Supported Scopes: country

count_owned_megastructure - Iterate through each owned megastructure - checks whether the enclosed triggers return true for X/all of them
count_owned_megastructure = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_system_megastructure - Iterate through each megastructure in system - checks whether the enclosed triggers return true for any of them
any_system_megastructure = { <triggers> }
Supported Scopes: all

count_system_megastructure - Iterate through each megastructure in system - checks whether the enclosed triggers return true for X/all of them
count_system_megastructure = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_member - Iterate through each member of the federation - checks whether the enclosed triggers return true for any of them
any_member = { <triggers> }
Supported Scopes: federation

count_member - Iterate through each member of the federation - checks whether the enclosed triggers return true for X/all of them
count_member = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: federation

any_associate - Iterate through each associate member of the federation - checks whether the enclosed triggers return true for any of them
any_associate = { <triggers> }
Supported Scopes: federation

count_associate - Iterate through each associate member of the federation - checks whether the enclosed triggers return true for X/all of them
count_associate = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: federation

any_system_planet - Iterate through each planet (colony or not) in the current system - checks whether the enclosed triggers return true for any of them
any_system_planet = { <triggers> }
Supported Scopes: galactic_object

count_system_planet - Iterate through each planet (colony or not) in the current system - checks whether the enclosed triggers return true for X/all of them
count_system_planet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_system_colony - Iterate through each colony in the current system - checks whether the enclosed triggers return true for any of them
any_system_colony = { <triggers> }
Supported Scopes: galactic_object

count_system_colony - Iterate through each colony in the current system - checks whether the enclosed triggers return true for X/all of them
count_system_colony = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_planet_within_border - Iterate through each planet within the current empire's borders - checks whether the enclosed triggers return true for any of them
any_planet_within_border = { <triggers> }
Supported Scopes: country

count_planet_within_border - Iterate through each planet within the current empire's borders - checks whether the enclosed triggers return true for X/all of them
count_planet_within_border = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_owned_planet - Iterate through each inhabited planet owned by the current empire - checks whether the enclosed triggers return true for any of them
any_owned_planet = { <triggers> }
Supported Scopes: country sector

count_owned_planet - Iterate through each inhabited planet owned by the current empire - checks whether the enclosed triggers return true for X/all of them
count_owned_planet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country sector

any_controlled_planet - Iterate through each inhabited planet controlled by the current empire - checks whether the enclosed triggers return true for any of them
any_controlled_planet = { <triggers> }
Supported Scopes: country

count_controlled_planet - Iterate through each inhabited planet controlled by the current empire - checks whether the enclosed triggers return true for X/all of them
count_controlled_planet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - checks whether the enclosed triggers return true for any of them
any_galaxy_planet = { <triggers> }
Supported Scopes: all

count_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - checks whether the enclosed triggers return true for X/all of them
count_galaxy_planet = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_deposit - Iterate through each deposit on the planet - checks whether the enclosed triggers return true for any of them
any_deposit = { <triggers> }
Supported Scopes: planet

count_deposit - Iterate through each deposit on the planet - checks whether the enclosed triggers return true for X/all of them
count_deposit = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_moon - Iterate through each moon of the planet - checks whether the enclosed triggers return true for any of them
any_moon = { <triggers> }
Supported Scopes: planet

count_moon - Iterate through each moon of the planet - checks whether the enclosed triggers return true for X/all of them
count_moon = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_pop_faction - Iterate through all the country's pop factions - checks whether the enclosed triggers return true for any of them
any_pop_faction = { <triggers> }
Supported Scopes: country

count_pop_faction - Iterate through all the country's pop factions - checks whether the enclosed triggers return true for X/all of them
count_pop_faction = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_owned_pop_group - Iterate through all owned pop groups - checks whether the enclosed triggers return true for any of them
any_owned_pop_group = { <triggers> }
Supported Scopes: planet country pop_faction sector

count_owned_pop_group - Iterate through all owned pop groups - checks whether the enclosed triggers return true for X/all of them
count_owned_pop_group = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country pop_faction sector

count_owned_pop_amount - Sums all pop amounts - checks whether the enclosed triggers return true for X/all of them
count_owned_pop_amount = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country pop_faction sector

any_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - checks whether the enclosed triggers return true for any of them
any_species_pop_group = { <triggers> }
Supported Scopes: species

count_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - checks whether the enclosed triggers return true for X/all of them
count_species_pop_group = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: species

any_owned_pop_job - Iterate through all owned pop jobs - checks whether the enclosed triggers return true for any of them
any_owned_pop_job = { <triggers> }
Supported Scopes: planet country sector

count_owned_pop_job - Iterate through all owned pop jobs - checks whether the enclosed triggers return true for X/all of them
count_owned_pop_job = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country sector

count_owned_workforce - Sums all workforce - checks whether the enclosed triggers return true for X/all of them
count_owned_workforce = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country sector

any_galaxy_sector - Iterate through all sectors in the game - checks whether the enclosed triggers return true for any of them
any_galaxy_sector = { <triggers> }
Supported Scopes: all

count_galaxy_sector - Iterate through all sectors in the game - checks whether the enclosed triggers return true for X/all of them
count_galaxy_sector = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_owned_sector - Iterate through every owned sector - checks whether the enclosed triggers return true for any of them
any_owned_sector = { <triggers> }
Supported Scopes: country

count_owned_sector - Iterate through every owned sector - checks whether the enclosed triggers return true for X/all of them
count_owned_sector = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_owned_ship - Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for any of them
any_owned_ship = { <triggers> }
Supported Scopes: country fleet

count_owned_ship - Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for X/all of them
count_owned_ship = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country fleet

any_controlled_ship - Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for any of them
any_controlled_ship = { <triggers> }
Supported Scopes: country fleet

count_controlled_ship - Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for X/all of them
count_controlled_ship = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country fleet

any_ship_in_system - Iterate through each ship in the current system - checks whether the enclosed triggers return true for any of them
any_ship_in_system = { <triggers> }
Supported Scopes: galactic_object

count_ship_in_system - Iterate through each ship in the current system - checks whether the enclosed triggers return true for X/all of them
count_ship_in_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_situation - Iterate through each situation a country is experiencing - checks whether the enclosed triggers return true for any of them
any_situation = { <triggers> }
Supported Scopes: country

count_situation - Iterate through each situation a country is experiencing - checks whether the enclosed triggers return true for X/all of them
count_situation = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_targeting_situation - Iterate through each situation that is targeting the current planet - checks whether the enclosed triggers return true for any of them
any_targeting_situation = { <triggers> }
Supported Scopes: planet

count_targeting_situation - Iterate through each situation that is targeting the current planet - checks whether the enclosed triggers return true for X/all of them
count_targeting_situation = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet

any_owned_pop_species - Iterate through each species of a country's owned pops - checks whether the enclosed triggers return true for any of them
any_owned_pop_species = { <triggers> }
Supported Scopes: country

count_owned_pop_species - Iterate through each species of a country's owned pops - checks whether the enclosed triggers return true for X/all of them
count_owned_pop_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_galaxy_species - Check if any species in the galaxy meet the specified criteria - checks whether the enclosed triggers return true for any of them
any_galaxy_species = { <triggers> }
Supported Scopes: all

count_galaxy_species - Check if any species in the galaxy meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
count_galaxy_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for any of them
any_owned_species = { <triggers> }
Supported Scopes: planet country

count_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
count_owned_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country

any_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for any of them
any_enslaved_species = { <triggers> }
Supported Scopes: planet country

count_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
count_enslaved_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: planet country

any_existing_species_traits - Iterate through all existing species traits in the game - checks whether the enclosed triggers return true for any of them
any_existing_species_traits = { <triggers> }
Supported Scopes: no_scope

count_existing_species_traits - Iterate through all existing species traits in the game - checks whether the enclosed triggers return true for X/all of them
count_existing_species_traits = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: no_scope

any_trait_of_species - Iterate through each trait that the scoped species has
trait_of_species = { trait_has_all_tags = { positive } } - checks whether the enclosed triggers return true for any of them
any_trait_of_species = { <triggers> }
Supported Scopes: pop pop_group leader species

count_trait_of_species - Iterate through each trait that the scoped species has
trait_of_species = { trait_has_all_tags = { positive } } - checks whether the enclosed triggers return true for X/all of them
count_trait_of_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: pop pop_group leader species

any_trait_available_for_species - Iterate through all species traits and check if scope species doesn't have this trait
traits_available_for_species = { trait_has_all_tags = { organic positive } } - checks whether the enclosed triggers return true for any of them
any_trait_available_for_species = { <triggers> }
Supported Scopes: pop pop_group leader species

count_trait_available_for_species - Iterate through all species traits and check if scope species doesn't have this trait
traits_available_for_species = { trait_has_all_tags = { organic positive } } - checks whether the enclosed triggers return true for X/all of them
count_trait_available_for_species = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: pop pop_group leader species

any_owned_starbase - Iterate through every owned primary starbase - checks whether the enclosed triggers return true for any of them
any_owned_starbase = { <triggers> }
Supported Scopes: country

count_owned_starbase - Iterate through every owned primary starbase - checks whether the enclosed triggers return true for X/all of them
count_owned_starbase = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - checks whether the enclosed triggers return true for any of them
any_owned_nonprimary_starbase = { <triggers> }
Supported Scopes: country

count_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - checks whether the enclosed triggers return true for X/all of them
count_owned_nonprimary_starbase = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country

any_starbase_in_system - Iterate through every starbase in the scoped galactic object. - checks whether the enclosed triggers return true for any of them
any_starbase_in_system = { <triggers> }
Supported Scopes: galactic_object

count_starbase_in_system - Iterate through every starbase in the scoped galactic object. - checks whether the enclosed triggers return true for X/all of them
count_starbase_in_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_system - Iterate through all systems - checks whether the enclosed triggers return true for any of them
any_system = { <triggers> }
Supported Scopes: all

count_system - Iterate through all systems - checks whether the enclosed triggers return true for X/all of them
count_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_rim_system - Iterate through all rim systems - checks whether the enclosed triggers return true for any of them
any_rim_system = { <triggers> }
Supported Scopes: all

count_rim_system - Iterate through all rim systems - checks whether the enclosed triggers return true for X/all of them
count_rim_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: all

any_system_within_border - Iterate through all systems within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
any_system_within_border = { <triggers> }
Supported Scopes: country sector

count_system_within_border - Iterate through all systems within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
count_system_within_border = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country sector

any_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - checks whether the enclosed triggers return true for any of them
any_neighbor_system = { <triggers> }
Supported Scopes: galactic_object

count_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - checks whether the enclosed triggers return true for X/all of them
count_neighbor_system = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - checks whether the enclosed triggers return true for any of them
any_neighbor_system_euclidean = { <triggers> }
Supported Scopes: galactic_object

count_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - checks whether the enclosed triggers return true for X/all of them
count_neighbor_system_euclidean = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: galactic_object

any_war_participant - Iterate through all war participants - checks whether the enclosed triggers return true for any of them
any_war_participant = { <triggers> }
Supported Scopes: war

count_war_participant - Iterate through all war participants - checks whether the enclosed triggers return true for X/all of them
count_war_participant = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: war

any_attacker - Iterate through all attackers in the current war - checks whether the enclosed triggers return true for any of them
any_attacker = { <triggers> }
Supported Scopes: war

count_attacker - Iterate through all attackers in the current war - checks whether the enclosed triggers return true for X/all of them
count_attacker = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: war

any_defender - Iterate through all defenders in the current war - checks whether the enclosed triggers return true for any of them
any_defender = { <triggers> }
Supported Scopes: war

count_defender - Iterate through all defenders in the current war - checks whether the enclosed triggers return true for X/all of them
count_defender = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: war

any_war - Iterate through all wars the country is engaged in - checks whether the enclosed triggers return true for any of them
any_war = { <triggers> }
Supported Scopes: country

count_war - Iterate through all wars the country is engaged in - checks whether the enclosed triggers return true for X/all of them
count_war = {
	count = <num/all/variable>
	limit = { <triggers> }
}
Supported Scopes: country


=================
[19:20:24][game_application.cpp:2223]: 
== EFFECT DOCUMENTATION ==
tooltip - Just a tooltip
Supported Scopes: all

win - The scoped country wins the game
win = yes
Supported Scopes: country

hidden_effect - Prevents enclosed effects from being displayed in tooltip
hidden_effect = { <effects> }
Supported Scopes: all

custom_tooltip - Displays a specific localization string in tooltip
custom_tooltip = <string>
Supported Scopes: all

if - Executes enclosed effects if limit criteria are met
if = { limit = { <triggers> } <effects> }
Supported Scopes: all

end_all_treaties_with - Ends all treaties with the target
end_all_treaties_with = <target>
Supported Scopes: country

random_list - Picks one random set of effects from a list, influenced by relative weight
random_list = { 50 = { <effects> } 20 = { <effects> } 30 = { <effects> } 999 = { <effects> } }
Supported Scopes: all

locked_random_list - Picks one random set of effects from a list, influenced by relative weight once per event scope
locked_random_list = { 50 = { <effects> } 20 = { <effects> } 30 = { <effects> } 999 = { <effects> } }
Supported Scopes: all

remove_deposit - Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
remove_deposit = <key/yes>
Supported Scopes: planet deposit astral_rift

add_blocker - Adds a blocker to a planet, with some control over what it is set to block (add_deposit will add a random planetary deposit to block)
add_blocker = {
	type = <key>
	blocked_deposit = none (default)/<deposit scope - copies the type to the blocked deposit but any flags or variables are lost>/random
}
Supported Scopes: planet

set_owner - Instantly sets the owner of the scoped planet/fleet/army/starbase to target country
set_owner = <target>
Supported Scopes: megastructure planet fleet leader army starbase

unemploy_pop - Fires scoped pop from its job
unemploy_pop = yes
Supported Scopes: pop

check_planet_employment - Immediately runs a job evaluation on the planet, firing and employing pops as needed
check_planet_employment = yes
Supported Scopes: planet

change_species_portrait - Changes the portrait of the species in scope.
change_species_portrait = <key or species event target>
Supported Scopes: species

add_random_non_blocker_deposit - Adds random non-blocker resource deposit to the scoped planet
add_random_non_blocker_deposit = yes
Supported Scopes: planet

remove_random_building - Removes last built building from the scoped planet
remove_random_building = yes
Supported Scopes: planet

remove_all_buildings - Removes all buildings from the scoped planet
remove_all_buildings = yes
Supported Scopes: planet

repair_all_buildings - Repairs all ruined buildings on the scoped planet
repair_all_buildings = yes
Supported Scopes: planet

downgrade_all_buildings - Downgrades all non-capital buildings on the scoped planet/country. Leaves tier 1 buildings untouched.
downgrade_all_buildings = yes
Supported Scopes: planet country

downgrade_buildings_of_type - Downgrades all buildings of a specified type on the planet/country.
downgrade_buildings_of_type = yes
Supported Scopes: planet country

validate_and_repair_planet_buildings_and_districts - Replace/removes all invalid (potential trigger not fulfilled) buildings and districts, then repairs all ruined buildings on the scoped planet
validate_and_repair_planet_buildings_and_districts = yes
Supported Scopes: planet

remove_holding - Removes a specific holding from the scoped planet
remove_holding = { holding = <key> owner = <owner> }
Supported Scopes: planet

add_holding - Begins construction of a specific holding on the scoped planet
add_holding = { holding = <key> owner = <owner> }
Supported Scopes: planet

give_technology - Instantly gives a specific tech to the scoped country
give_technology = { tech = tech_desert_colonization message = yes }
Supported Scopes: country

add_building - Begins construction of a specific building on the scoped planet
	add_building = <key>
or
	add_building = {
		district = <district_type_key>
		zone = <zone_type_key>
		building = <building_type_key>
	}
Supported Scopes: planet

ruin_building - Ruins a single instance of a specific building on the scoped planet
	ruin_building = <building_type_key>/random_no_capital
Supported Scopes: planet

disable_building - Disables a single instance of a specific building on the scoped planet
	disable_building = <building_type_key>
Supported Scopes: planet

change_background_ethic - Changes the background ethic of a leader
change_background_ethic = <key>
Supported Scopes: leader

change_background_job - Changes the background job of a leader
change_background_job = <key>
Supported Scopes: all

add_planet_devastation - Instantly adds devastation to scoped planet
add_planet_devastation = 5
Supported Scopes: planet

set_immortal - Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
set_immortal = yes
Supported Scopes: leader

freeze_leader_age - Freezes the scoped leader's age. The 'no' case will disable the freeze granted by this effect.
freeze_leader_age = yes
Supported Scopes: leader

calculate_modifier - Forces target planet or country to calculate its internal modifier
calculate_modifier = yes
Supported Scopes: planet country

establish_branch_office - Establish branch office on scoped planet for target country
establish_branch_office = <target>
Supported Scopes: planet

close_branch_office - Close branch office on scoped planet
close_branch_office = yes
Supported Scopes: planet

clear_blockers - Removes all blockers from the scoped planet
clear_blockers = yes
Supported Scopes: planet

set_built_species - Changes the built species of the scoped object
set_built_species = <target>
Supported Scopes: country

set_first_contact_flag - Sets an arbitrarily-named flag on the scoped first contact site
set_first_contact_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: first_contact

set_situation_flag - Sets an arbitrarily-named flag on the scoped situation
set_situation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: situation

set_agreement_flag - Sets an arbitrarily-named flag on the scoped agreement
set_agreement_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: agreement

set_federation_flag - Sets an arbitrarily-named flag on the scoped federation
set_federation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: federation

set_country_flag - Sets an arbitrarily-named flag on the scoped country
set_country_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: country

set_planet_flag - Sets an arbitrarily-named flag on the scoped planet
set_planet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: planet

set_fleet_flag - Sets an arbitrarily-named flag on the scoped fleet
set_fleet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: fleet

set_ship_flag - Sets an arbitrarily-named flag on the scoped ship
set_ship_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ship

set_astral_rift_flag - Sets an arbitrarily-named flag on the scoped astral rift
set_astral_rift_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: astral_rift

remove_first_contact_flag - Removes a flag from the scoped first contact site
remove_first_contact_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: first_contact

remove_situation_flag - Removes a flag from the scoped situation
remove_situation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: situation

remove_agreement_flag - Removes a flag from the scoped agreement
remove_agreement_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: agreement

remove_federation_flag - Removes a flag from the scoped federation
remove_federation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: federation

remove_country_flag - Removes a flag from the scoped country
remove_country_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: country

remove_planet_flag - Removes a flag from the scoped planet
remove_planet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: planet

remove_fleet_flag - Removes a flag from the scoped fleet
remove_fleet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: fleet

remove_ship_flag - Removes a flag from the scoped ship
remove_ship_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ship

remove_astral_rift_flag - Removes a flag from the scoped astral rift
remove_astral_rift_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: astral_rift

create_species - Creates a new species. The habitability trait is determined by homeworld, traits = random, traits = { ideal_planet_class = <pc_XYZ> }, traits = <trait_pc_XYZ_preference>, or else is assigned randomly.
create_species = {
	name = <string>/random/scope
	plural = <string>/this
	class = <species class key>/random/random_non_machine/random_pre_ftl/scope
	portrait = <random/portrait id>/this
	homeworld = <target>
	traits = { <traits> }/random/this
	sapient = yes/no, determines if species is sapient (default: yes)
	is_mod = yes/no, determines if species is a modification of another (default: no)
	immortal = yes/no, determines if species leaders are immortal (default: no)
	can_be_modified = yes/no/this (default: yes)
	gender = <species/leader>/male/female/indeterminate/not_set
	clear_parent_species_link = yes/no (default: no)
	extra_trait_points = <int>
	allow_negative_traits = yes/no (default: yes)
	namelist = random/random_class/scope
	effect = {}
}
Supported Scopes: all

create_country - Creates a new country
create_country = {
	name = <string/random>
	adjective = <string>
	contact_rule = <string>
 type = <key>
	auto_delete = <bool>
	name_list = <key>
	ship_prefix = <string>
	authority = <key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	flag = <random / { icon = { category = <key> file = <filename.dds> } background = { category = <key> file = <filename.dds> } colors = { <key> <key> } }
	ethos = <random / { ethic = <key> ethic = <key> }>
	restrictions = { <restrictions, see "common\governments\readme_requirements.txt"> }
	set_capital_from_species = yes/no
	effect = { <effects executed on country> }
	graphical_culture = <culture_key>
	city_graphical_culture = <culture_key>
	ship_kinds = { <ship_category_keys> }
	room = <room_texture_key>
}
Supported Scopes: all

create_fleet - Creates a new fleet
create_fleet = { name = <string> effect = { <create_ship, set_owner, set_location etc effects go here> } } 
Supported Scopes: all

create_army - Creates a new army
create_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}
Supported Scopes: planet

modify_army - Modifies army with parameters:
modify_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}
Supported Scopes: army

set_location - Sets the fleet/ambient object's location, can be fine-tuned
set_location = <target>
set_location = {
	target = <target>
	distance = <int/random>
	angle = <int/random>
	direction = <in_system/out_system>
}
Supported Scopes: fleet ambient_object

create_ship - Creates a new ship
create_ship = {
	name = <string/random>
	design = <ship design key/target/last_created_design, or use random_existing_design>
	random_existing_design = <ship size key>
	graphical_culture = <graphical culture key> graphical_culture_fallback = <graphical culture key>
prefix = <Y/N, determines if ship name should use owner country prefix>
	colonizer_species = <species, default: fleet owner founder species> age = <int> (optional)
	rarity = <common/rare/epic/exceptional, used only if ship is space fauna> (optional, fallbacks to highest owned genetic material if applicable but not set)
	growth_stage = <integer value between 1 and the amount of growth stages in the design> (optional, use the first growth stage by default)
}
Supported Scopes: fleet starbase

set_awareness - Sets awareness for the scoped (pre-FTL) country
set_awareness = 52.3
Supported Scopes: country

add_awareness - Adds awareness to the scoped (pre-FTL) country
add_awareness = 12.3
Supported Scopes: country

create_pop - Adds pop size on the scoped planet
create_pop = {
	species = <target / key>
	ethos = <random / <target country> / { ethic = <key> ethic = <key> }
	size = <number> (optional, default: POP_BULK_UNIT_SIZE) }>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: planet

create_pop_group - Creates a new pop group based on an existing one with overrides. If no existing pop group is passed, species is mandatory.
create_pop_group = {
	pop_group = <base pop group> (optional; if omitted, species is required)
	species = last_created / <key> / <target> / random (optional; if omitted, base pop group is required)
	ethos = { ethic = <key> } / random (optional; if no base group and no ethic is provided, ethos will be randomized)
	category = <pop category> (optional; if omitted and no base group is defined, use category from first assigned job)
	size = <number> (optional, default: POP_BULK_UNIT_SIZE)
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
	effect = <init effect> (optional)
}
Supported Scopes: planet

create_colony - Creates a colony on the scoped planet
create_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}
Supported Scopes: planet

set_capital - Sets the scoped planet to be the capital of its owner country
set_capital = yes
Supported Scopes: planet

change_pc - Changes the class of the scoped planet
change_pc = <class/random list>
change_pc = { class = <class/random list> inherit_entity = yes }
Supported Scopes: planet

start_terraform_process - Starts terraforming process of scoped planet
start_terraform_process = <class/random list>
start_terraform_process = { class = <class/random list> inherit_entity = yes }
Supported Scopes: planet

set_star_class - Sets the star's star class, affecting system and galactic map graphics and potentially modifiers. Also changes the planet class of the system's primary star.
set_star_class = <star class>
Supported Scopes: galactic_object

kill_pop_group - Instantly destroys part of a pop group
kill_pop_group = {
	pop_group = <target pop group>
	amount = <amount killed> OR percentage = <percentage killed>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: all

destroy_colony - Destroys the colony on the scoped planet
destroy_colony = yes
Supported Scopes: planet

add_experience - Adds a sum of experience points to the scoped leader
add_experience = 200
Supported Scopes: leader

set_ring - Adds or removes a planetary ring around the scoped planet
set_ring = no
Supported Scopes: planet

create_mining_station - Creates a mining station in orbit of the scoped planet
create_mining_station = { owner = <target> }
Supported Scopes: planet astral_rift

create_research_station - Creates a research station in orbit of the scoped planet
create_research_station = { owner = <target> }
Supported Scopes: planet astral_rift

set_pop_flag - Sets an arbitrarily-named flag on the scoped pop
set_pop_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop

remove_pop_flag - Removes a flag from the scoped pop
remove_pop_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop

set_pop_group_flag - Sets an arbitrarily-named flag on the scoped pop group
set_pop_group_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop_group

remove_pop_group_flag - Removes a flag from the scoped pop group
remove_pop_group_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop_group

set_name - Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
set_name = <string>/<target>
Supported Scopes: megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact

set_adjective - Sets the adjective of the scoped country
set_adjective = <string>
Supported Scopes: country

set_ship_prefix - Sets the ship prefix of the scoped country
set_ship_prefix = <string>
Supported Scopes: country

add_modifier - Adds a specific modifier to the scoped object for a set duration
add_modifier = {
	modifier = <key>
	days/months/years = <int, -1 (default) means it never expires>
	multiplier = <float>/<variable> (optional)
	time_multiplier = <variable> (optional: days/months/years value is multiplied by the value of this variable)
	clear_on_owner_change = yes (optional: default no; clears modifier if planet/system/megastructure's owner changes)
}
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift cosmic_storm_influence_field

reduce_hp - Reduces the hull points of the scoped ship by a specific amount
reduce_hp = 120
Supported Scopes: ship

reduce_hp_percent - Reduces the hull points of the scoped ship by a relative amount
reduce_hp_percent = 0.25
Supported Scopes: ship

reduce_shield - Reduces the shield points of the scoped ship by a specific amount
reduce_shield = 120
Supported Scopes: ship

damage_ship - Damages ship by a specific amount
damage_ship = 120
Supported Scopes: ship

damage_army - Damages scoped army by a specific amount
damage_army = 250
Supported Scopes: army

repair_ship - Restores all hull points to the scoped ship
repair_ship = yes
Supported Scopes: ship

set_surveyed - Sets the planet/astral rift or system as un/surveyed by target country
set_surveyed = { surveyed = yes surveyor = <target> }
Supported Scopes: planet galactic_object astral_rift

set_visited - Sets the target system as 'visited' (i.e. low system intel on the map)
set_visited = <target>
Supported Scopes: country

destroy_country - Destroys the scoped country
destroy_country = yes
Supported Scopes: country

set_variable - Sets or creates an arbitrarily-named variable with a specific value in the current scope
set_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

clear_variable - Clears a previously-set variable from the game.
clear_variable = <string>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

round_variable - Rounds a previously-set variable to the closest integer.
round_variable = <string>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

floor_variable - Rounds a previously-set variable down to the previous integer.
floor_variable = <string>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

ceiling_variable - Rounds a previously-set variable up to the next integer.
ceiling_variable = <string>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

export_modifier_to_variable - Exports the value of a specified modifier in the current scope to a specified variable.
export_modifier_to_variable = { modifier = logistic_growth_mult variable = <string> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army species pop_faction

export_modifier_duration_to_variable - Exports the remaining duration of a specified modifier in the current scope to a specified variable.
export_modifier_duration_to_variable = { modifier = modifier_name variable = <string> }
Supported Scopes: planet country pop pop_group fleet

export_trigger_value_to_variable - Exports the value of a trigger to a specified variable (so for num_pops, it'll export the number of pops).
export_trigger_value_to_variable = {
	trigger = has_resource
	parameters = { resource = energy } (optional: specify extra parameters for triggers with { }
	variable = <string> (this example will print the amount of energy the scoped object has to a variable)
	rounded = yes (default: no)
}
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

export_resource_stockpile_to_variable - Exports the value of the current country's stockpile of the specified resource to a variable.
export_resource_stockpile_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

export_resource_income_to_variable - Exports the value of the current country's monthly income of the specified resource to a variable.
export_resource_income_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

export_resource_maximum_to_variable - Exports the value of the current country's maximum of the specified resource to a variable.
export_resource_maximum_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

set_variable_to_random_value - Sets a variable to a random value within the specified bounds.
set_variable_to_random_value = { which = <some_variable> min = -100 max = 100 rounded = yes/no }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

remove_global_flag - Removes a global flag
remove_global_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: all

set_global_flag - Sets an arbitrarily-named global flag
set_global_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: all

change_variable - Increments a previously-set variable by a specific amount
change_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

set_event_locked - Silently disables the scoped fleet to prevent player action, remember to unlock at the end of the event
set_event_locked = no
Supported Scopes: fleet

clear_orders - Clears all fleet orders from the scoped fleet
clear_orders = yes
Supported Scopes: fleet

order_forced_return - Forces scoped fleet to retreat to friendly territory
order_forced_return = yes
Supported Scopes: fleet

declare_war - Declares war between the scoped country and target country
declare_war = {
	target = <target country>
	name = <optional war name>
	attacker_war_goal = <war goal>
}
Supported Scopes: country

set_star_flag - Sets an arbitrarily-named flag on the scoped system
set_star_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: galactic_object

remove_star_flag - Removes a flag from the scoped system
remove_star_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: galactic_object

set_army_flag - Sets an arbitrarily-named flag on the scoped army
set_army_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: army

set_deposit_flag - Sets an arbitrarily-named flag on the scoped deposit
set_deposit_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: deposit

set_war_flag - Sets an arbitrarily-named flag on the scoped war
set_war_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: war

set_starbase_flag - Sets an arbitrarily-named flag on the scoped starbase
set_starbase_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: starbase

set_sector_flag - Sets an arbitrarily-named flag on the scoped sector
set_sector_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: sector

set_archaeology_flag - Sets an arbitrarily-named flag on the scoped arc site
set_archaeology_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: archaeological_site

set_spynetwork_flag - Sets an arbitrarily-named flag on the scoped spy network
set_spynetwork_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: spy_network

set_espionage_asset_flag - Sets an arbitrarily-named flag on the scoped espionage asset
set_espionage_asset_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_asset

remove_army_flag - Removes a flag from the scoped army
remove_army_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: army

remove_deposit_flag - Removes a flag from the scoped deposit
remove_deposit_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: deposit

remove_war_flag - Removes a flag from the scoped war
remove_war_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: war

remove_starbase_flag - Removes a flag from the scoped starbase
remove_starbase_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: starbase

remove_sector_flag - Removes a flag from the scoped sector
remove_sector_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: sector

remove_archaeology_flag - Removes a flag from the scoped arc site
remove_archaeology_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: archaeological_site

remove_spynetwork_flag - Removes a flag from the scoped spy network
remove_spynetwork_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: spy_network

remove_espionage_asset_flag - Removes a flag from the scoped espionage asset
remove_espionage_asset_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_asset

set_spawn_system_batch - Optimizes the calls for spawn_system effect. Spawn system should be located in a block between Begin and End.
Begin: set_spawn_system_batch = begin
End: set_spawn_system_batch = end
Supported Scopes: all

spawn_system - Spawns a new system at a position relative to the scoped system/planet/ship.
spawn_system = { min_jumps = <value> max_jumps = <value> min_distance = <int 0-100> max_distance = <int 0-100> initializer = <key for pre-defined system>/random hyperlane=<yes/no> is_discovered=<yes/no>}
Supported Scopes: megastructure planet ship fleet galactic_object starbase no_scope

create_nebula - Creates a new Nebula with a given radius centered around the current system.
create_nebula = {
	name = <name> (loc synced, optional - default is random)
	radius = 100
	effect = { <effects on every system in the new nebula> }
}
Supported Scopes: galactic_object

dismantle - Dismantles the scoped orbital station (fleet)
dismantle = yes
Supported Scopes: fleet

set_advisor_active - Enables or disables the VIR window pop-in
set_advisor_active = no
Supported Scopes: country

save_event_target_as - Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_event_target_as = <string>/<string@scope>
Supported Scopes: all

save_global_event_target_as - Saves the current scope as an arbitrarily-named target to be referenced later, accessible globally until cleared
save_global_event_target_as = <string>/<string@scope>
Supported Scopes: all

clear_global_event_target - Deletes the specified saved global target reference
clear_global_event_target = <string>/<string@scope>
Supported Scopes: all

clear_global_event_targets - Deletes all saved global target references
clear_global_event_targets = yes
Supported Scopes: all

store_country_backup_data - Stores a copy of the specified data of the scoped country. The values default to 'no'.
store_country_backup_data = {
flag = <yes/no>
room = <yes/no>
name = <yes/no
ethics = <yes/no>
government = <yes/no>
}
Supported Scopes: country

restore_country_backup_data - Restores backed up data to the scoped country.
See store_country_backup_data for what data can be backed up.
restore_country_backup_data = <yes/no>
Supported Scopes: country

break - Prevents execution of subsequent effects in the same effect block, used with if-statements
break = yes
Supported Scopes: all

set_tutorial_level - Changes the scoped country's tutorial level (0 none, 1 limited, 2 full)
set_tutorial_level = 0
Supported Scopes: country

begin_event_chain - Starts a situation log event chain for target country
begin_event_chain = { event_chain = <key> target = <target> }
Supported Scopes: all

end_event_chain - Ends a specific situation log event chain for the scoped country
end_event_chain = <key>
Supported Scopes: country

queue_actions - Adds actions to the scoped fleet's action queue
queue_actions = { repeat = { <fleet actions> } }
Supported Scopes: fleet

clear_fleet_actions - Clears all queued fleet actions for target fleet
clear_fleet_actions = <target>
Supported Scopes: fleet

destroy_fleet - Destroys the target fleet (with death graphics)
destroy_fleet = <target>
destroy_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}
Supported Scopes: all

destroy_and_spawn_debris_for - Sets the current ship or fleet to be destroyed and spawn a debris project for the specified country.
destroy_and_spawn_debris_for = from
Supported Scopes: ship fleet

create_ambient_object - Creates a new ambient object
create_ambient_object = { type = <key> location = <target> }
For VFX use:
create_ambient_object = {
	type = <key>
	scale = <float>
	location = <target>
	use_3d_location = <bool, use 3D entity or 2D coordinate of the location entity as base>
	entity_offset = {
		min = <int>
		max = <int>
	}
	entity_offset_angle = {
		min = <int>
		max = <int>
	}
	entity_offset_height = {
		min = <int>
		max = <int>
	}
	entity_face_object = star/FROM/etc
	entity_scale_to_size = yes/no
	play_animation_once = yes/no
	target = <target>
	duration = <int, days>
}
Supported Scopes: all

destroy_ambient_object - Destroys target ambient object
destroy_ambient_object = <target>
Supported Scopes: all

add_trait - Adds a specific trait to the scoped leader or a random common/negative trait
add_trait = {
	trait = <trait>/random_common/random_negative
	consume_selection = yes/no (if yes and leader has unspent trait selections, consume one of them; default: no)
	show_message = yes/no (default: yes)
}
Supported Scopes: leader

remove_trait - Removes a specific trait from the scoped leader, or removes all negative traits
remove_trait = <key/all_negative>
Supported Scopes: leader

remove_all_negative_traits - Removes all negative traits from the scoped leader
remove_all_negative_traits = yes
Supported Scopes: leader

remove_all_positive_traits - Removes all non-negative traits from the scoped leader
remove_all_positive_traits = yes
Supported Scopes: leader

remove_all_traits - Removes all traits from the scoped leader
remove_all_traits = yes
Supported Scopes: leader

modify_species - Creates a new, modified species based on an already-extant species
modify_species = {
	species = <target> # species to modify
	base = <target>/auto/none # new base species; default: auto (uses species)
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	ideal_planet_class = <target or pc_name> # optional
	change_scoped_species = yes/no # modify scoped pop group/planet/leader/country; default: yes
	portrait = <target or portrait name> # optional
	add_random_trait = { <trigger> } adds a random trait filtered by the given trigger, the Scope is the trait token, and the original scope is in Prev 
	on_random_trait_added = { <effect> } effect is fired for randomly selected trait, the Scope is the trait, the original scope is in Prev, and From contains Species 
	sapient = <Y/N, determines if species is pre-sapient>
	effect = { SCOPE_SPECIES } # optional effect to run on the resulting new species, is executed after any handling of change_scoped_species
}
Supported Scopes: planet country pop pop_group leader species

add_opinion_modifier - Adds a specific opinion modifier for the scoped country towards target country
add_opinion_modifier = { modifier = <key> who = <target> }
Supported Scopes: country

establish_contact - Establishes first contact between the scoped country and target country at the set location
establish_contact = { who = <target> location = <target> }
Supported Scopes: country

set_hostile - Sets the target country as hostile. This will work on countries you don't have comms with, unlike set_faction_hostility.
set_hostile = from
Supported Scopes: country

set_faction_hostility - Sets the aggro state of the scoped faction-type country
set_faction_hostility = { target = country set_hostile = yes set_neutral = no set_friendly = no }
Supported Scopes: country

set_market_leader - Set scoped country as the current Galactic Market leader.
set_market_leader = <yes/no> 
Supported Scopes: country

add_event_chain_counter - Increments (or decrements with negative values) an event chain counter for the scoped country by a specific amount
add_event_chain_counter = { event_chain = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

add_anomaly - Adds a specific anomaly category to the scoped planet
add_anomaly = {
	category = <key>
	target = target:country
}
Supported Scopes: all

set_disable_at_health - Sets the scoped ship to become disabled at a certain hull point percentage
set_disable_at_health = <0-1 float> | no
Supported Scopes: ship fleet

remove_building - Removes a single instance of a specific building from the scoped planet
	remove_building = <building_type_key>
Supported Scopes: planet

add_zone - Adds zone to the district of the planet
	add_zone = {
		district = <district_type_key/district_slot_index>
		zone = <zone_type_key>
		zone_slot = <zone_slot_index>
		replace = <yes/no>
	}
Supported Scopes: planet

change_planet_size - Increases or reduces the size of the scoped planet by a specified amount
change_planet_size = <+/- int>
Supported Scopes: planet

set_policy_cooldown - Sets the specified policy group to have a cooldown as if the policy had just been changed.
set_policy_cooldown = <policy group e.g. diplomatic_stance>
Supported Scopes: country

reset_policy_cooldowns - Resets the cooldown period of all policies for a country
reset_policy_cooldowns = yes
Supported Scopes: country

create_point_of_interest - Creates a point of interest for the scoped country at a specific location, associated with an event chain
create_point_of_interest = { id = <key> name = <string> desc = <string> event_chain = <key> location = <target> }
Supported Scopes: planet country ship pop pop_group

remove_point_of_interest - Removes a specific point of interest from the scoped country's situation log
remove_point_of_interest = <key>
Supported Scopes: country

set_relation_flag - Sets a relation flag for the scoped country towards target country
set_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

remove_relation_flag - Removes a specific relation flag towards target country from the scoped country
remove_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

kill_leader - Kills the scoped leader or leader of the scoped country/fleet/ship/planet/army/first contact system/spy network
kill_leader = {
	class = <key, optional, if left out will kill scoped leader, can be used multiple times>
	ability = <key, optional, see leader class for list of abilities, will kill leader that has this ability, can be used multiple times>

	show_notification = <yes/no>
	heir = <yes, optional, if added to type = ruler, will kill heir instead>
	fire = yes (default: no; if yes, fires on_leader_fired instead of on_leader_death
}
Supported Scopes: planet country ship fleet leader army

assign_leader - Assigns target leader to the scoped country/fleet/army/
assign_leader = <target>
Supported Scopes: planet country fleet army

set_years_served - Copies years served duration from the target
set_years_served = <target>
Supported Scopes: leader

country_add_ethic - Adds a specific ethic to the scoped country
country_add_ethic = <key>
Supported Scopes: country

country_remove_ethic - Removes a specific ethic from the scoped country
country_remove_ethic = <key>
Supported Scopes: country

set_timed_first_contact_flag - Sets an arbitrarily-named flag on the scoped first contact site for a set duration
set_timed_first_contact_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: first_contact

set_timed_situation_flag - Sets an arbitrarily-named flag on the scoped situation for a set duration
set_timed_situation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: situation

set_timed_agreement_flag - Sets an arbitrarily-named flag on the scoped agreement for a set duration
set_timed_agreement_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: agreement

set_timed_federation_flag - Sets an arbitrarily-named flag on the scoped federation for a set duration
set_timed_federation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: federation

set_timed_country_flag - Sets an arbitrarily-named flag on the scoped country for a set duration
set_timed_country_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: country

set_timed_fleet_flag - Sets an arbitrarily-named flag on the scoped fleet for a set duration
set_timed_fleet_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: fleet

set_timed_global_flag - Sets an arbitrarily-named global flag for a set duration
set_timed_global_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: all

set_timed_planet_flag - Sets an arbitrarily-named flag on the scoped planet for a set duration
set_timed_planet_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: planet

set_timed_pop_flag - Sets an arbitrarily-named flag on the scoped pop for a set duration
set_timed_pop_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: pop

set_timed_pop_group_flag - Sets an arbitrarily-named flag on the scoped pop group for a set duration
set_timed_pop_group_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: pop_group

set_timed_relation_flag - Sets an arbitrarily-named flag for the scoped country towards target country for a set duration
set_timed_relation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	who = <target>
	days/months/years = <int>
}
Supported Scopes: country

set_timed_ship_flag - Sets an arbitrarily-named flag on the scoped ship for a set duration
set_timed_ship_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: ship

set_timed_star_flag - Sets an arbitrarily-named flag on the scoped system for a set duration
set_timed_star_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
Supported Scopes: galactic_object

set_timed_army_flag - Sets an arbitrarily-named flag on the scoped army for a set duration
set_timed_army_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: army

set_timed_deposit_flag - Sets an arbitrarily-named flag on the scoped deposit for a set duration
set_timed_deposit_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: deposit

set_timed_war_flag - Sets an arbitrarily-named flag on the scoped war for a set duration
set_timed_war_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: war

set_timed_starbase_flag - Sets an arbitrarily-named flag on the scoped starbase for a set duration
set_timed_starbase_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: starbase

set_timed_sector_flag - Sets an arbitrarily-named flag on the scoped sector for a set duration
set_timed_sector_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: sector

set_timed_archaeology_flag - Sets an arbitrarily-named flag on the scoped arc site for a set duration
set_timed_archaeology_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: archaeological_site

set_timed_spynetwork_flag - Sets an arbitrarily-named flag on the scoped spy network for a set duration
set_timed_spynetwork_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: spy_network

set_timed_espionage_asset_flag - Sets an arbitrarily-named flag on the scoped espionage asset for a set duration
set_timed_espionage_asset_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: espionage_asset

set_saved_date - Sets an arbitrarily-named date flag for the scoped object. Acts both as an <scope object>_flag and as a means for saving a date. The flag can then be referred to in localisations [This.<flag>] to produce the date.
set_saved_date = {
	key = <key> (refer to this in locs; note: this is actually a <country/whatever>_flag)
	days_from_present = <int>/<variable> (time until the date you wish to save)
	expires = <int>/<variable> (time until the saved date is cleared, default is never)
}
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

remove_modifier - Removes a specific modifier from the scope object
remove_modifier = <key>
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift cosmic_storm_influence_field

add_ship_design - Adds a specific ship design to the scoped country
add_ship_design = <target/last_created_design>
Supported Scopes: country

add_mission_progress - Adds or subtracts progress to/from the scoped observation post's current mission
add_mission_progress = <+/- float>
Supported Scopes: fleet

create_army_transport - Creates a new army in a new transport ship
create_army_transport = {
	ship_name = <string>
	graphical_culture = <key>
	army_name = <string>
	army_type = <key>
	species = <target>
}
Supported Scopes: fleet

switch - Executes the first appropriate effect set for a specific trigger
switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}
Supported Scopes: all

set_pop_faction - Sets the scoped pop group to belong to a specific pop faction
set_pop_faction = <target>
Supported Scopes: pop pop_group

set_graphical_culture - Sets the scoped object's graphical culture
set_graphical_culture = <key>
Supported Scopes: megastructure country starbase

set_formation_scale - Scales the scoped fleet's formation's ship spacing, above and below 1.0
set_formation_scale = <float>
Supported Scopes: fleet

set_controller - Instantly sets the planet/fleet's controller to target country. If the fleet is a starbase, starts occupation, otherwise the fleet is leased out.
set_controller = <target>
Supported Scopes: planet fleet

force_faction_evaluation - Forces target pop group to immediately evaluate their attraction to various pop factions
force_faction_evaluation = yes
Supported Scopes: pop_group

enable_faction_of_type - Forces scoped country to evaluate whether to create a specific faction type immediately, rather than monthly
enable_faction_of_type = <key>
Supported Scopes: country

clear_uncharted_space - Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
clear_uncharted_space = <target>
Supported Scopes: country

establish_communications - Establish communications between scoped country and target country
establish_communications = <target>
Supported Scopes: country

add_monthly_resource_mult - Adds a lump sum of a resource to the scoped country, defined as a multiple of the country's monthly income of that resource (clamped to max and min allowed values)
add_monthly_resource_mult = { resource = <key> value = <float> max = <max cap, int> min = <min cap, int> mult = <variable> }
Supported Scopes: country

set_leader_flag - Sets an arbitrarily-named flag on the scoped leader
set_leader_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: leader

remove_leader_flag - Removes a flag from the scoped leader
remove_leader_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: leader

add_research_option - Adds a tech research option to the scoped country's tech view list, permanent until researched
add_research_option = <key>
Supported Scopes: country

set_heir - Sets the target leader to be the scoped country's heir
set_heir = <target>
Supported Scopes: country

leave_alliance - Removes scoped country from any alliances it is in
leave_alliance = {
	override_requirements = yes/no (default: no)
	apply_opinion_penalty = yes (default: no; sets whether 'Broke Federation' opinion is applied)
}
Supported Scopes: country

set_policy - Sets a policy to a specific option for the scoped country and specifies if policy cooldown should go into effect
set_policy = { policy = <key> option = <key> cooldown = <bool> }
Supported Scopes: country

recruitable - Sets scoped leader as non/recruitable
recruitable = yes
Supported Scopes: leader

closest_system - Executes enclosed effects on a system -within a specific number of jumps span- that meets the limit criteria. This completely ignores bypasses (wormholes and gateways)
closest_system = {
	min_steps = <int, minimum # of systems 'away'>
	max_steps = <int, maximum # of systems 'away'>
	use_bypasses = yes/no (default: no)
	limit = { <triggers> }
	<effects>
}
Supported Scopes: all

set_ambient_object_flag - Sets an arbitrarily-named flag on the scoped ambient object
set_ambient_object_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ambient_object

set_timed_ambient_object_flag - Sets an arbitrarily-named flag on the scoped ambient object for a set duration
set_timed_ambient_object_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: fleet

remove_ambient_object_flag - Removes a flag from the scoped ambient object
remove_ambient_object_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ambient_object

set_aggro_range - Sets the scoped fleet/country's aggro range in intra-system units
set_aggro_range = <int>
Supported Scopes: country fleet

set_fleet_stance - Sets the stance of the scoped fleet
set_fleet_stance = <key, aggressive/passive/evasive>
Supported Scopes: fleet

add_favors - Add <value> favors for scoped country to use on target country.
add_favor = {
	target = <target>
	value = 2/variable
}
Supported Scopes: country

remove_favors - Remove <value/all> favors that scoped country have on target country:
remove_favors = {
target = <target>
value = <value/all/variable> }
Supported Scopes: country

set_aggro_range_measure_from - Determines whether the scoped fleet/country's aggro range is measured from the fleet's current position or its spawn location
set_aggro_range_measure_from = <key, self/return_point>
Supported Scopes: country fleet

establish_communications_no_message - Silently establish communications between scoped country and target country
establish_communications_no_message = <target>
Supported Scopes: country

remove_war_participant - Removes a specified country from the war
remove_war_participant = <target>
Supported Scopes: war

set_subject_of - Sets the scoped country to be a subject of target country. If use_demanded_terms is set to yes, then the subject agreement will use terms that have previously been demanded in a diplomatic action. If allow_instant_negotiation is set to yes, then the subject and overlord can re-negotiate their agreement right away without having to way for the cooldown. If preset is specified, then the agreement will start as that preset
set_subject_of = { who = <target>
use_demanded_terms = yes
allow_instant_negotiation = yes
preset = <preset_name> [optional] }
Supported Scopes: country

unassign_leader - Unassigns scoped leader from their post or unassigns leader from the scoped planet/ship/fleet/army
unassign_leader = <target>
Supported Scopes: ship fleet leader army

exile_leader_as - Exiles the scoped country/fleet/army/leader and saves them with a custom name
exile_leader_as = <key>/<key@scope>
Supported Scopes: country fleet leader army

set_leader - Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction
set_leader = <key>/<key@scope>
Supported Scopes: country fleet army

add_skill - Adds to the scoped leader's skill level
add_skill = 2
Supported Scopes: leader

set_skill - Sets the scoped leader's level
set_skill = 3
Supported Scopes: leader

set_federation_leader - Sets a country to lead a federation
set_federation_leader = <target>
Supported Scopes: country federation

add_colony_progress - Adds to ongoing colonization progress on the scoped planet
add_colony_progress = <0.0-1.0>
Supported Scopes: planet

start_colony - Starts colonization of the scoped planet
start_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}
Supported Scopes: planet

subtract_variable - Decrements a previously-set variable by a specific amount
subtract_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

multiply_variable - Multiplies a previously-set variable by a specific amount
multiply_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

divide_variable - Divides a previously-set variable by a specific amount
divide_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

modulo_variable - Modulos a previously-set variable by a specific amount i.e. X % Y
modulo_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

round_variable_to_closest - Rounds a previously-set variable to the closest X
round_variable_to_closest = {
	which = <string>
	value = <float>/<variable>/<scope.variable>/trigger:<trigger> (variable will be rounded to a multiple of this value)
}
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

play_sound - Play the defined sound effect
play_sound = myfirstsoundeffect
Supported Scopes: all

set_crisis_sound - Sets the crisis ambient loop to the current effect
set_crisis_sound = myfirstsoundeffect
Supported Scopes: all

stop_crisis_sound - Stops the crisis ambient loop
stop_crisis_sound = yes
Supported Scopes: all

multiply_crisis_strength - Multiplies crisis strength by this factor.
multiply_crisis_strength = 1.5
Supported Scopes: all

force_add_civic - Adds civic to a government without checking the restrictions
force_add_civic = <civic>
Supported Scopes: country

force_remove_civic - Removes civic from a government without checking the restrictions
force_remove_civic = <civic>/2
Supported Scopes: country

set_origin - Sets the country's origin to a certain value. Note: This will not run effects executed during galaxy generation.
set_origin = <origin>
Supported Scopes: country

set_gender - Sets the gender of the scoped leader
set_gender = female
Supported Scopes: leader

copy_flags_and_variables_from - Copies all script flags and variables from the specified scope to the current one.
copy_flags_and_variables_from = event_target:them
Supported Scopes: all

reroll_random - Rerolls the random seed. Use if you want to have a second random_list return a different result. Do not use in tooltips that show random results, because the tooltip will be wrong!
reroll_random = yes
Supported Scopes: all

create_fleet_from_naval_cap - Creates a new fleet from empire designs up to specified fraction of naval cap
create_fleet_from_naval_cap = 0.5
create_fleet_from_naval_cap = { fraction = 0.5 ship_owner_type = <country/federation/galactic_community>
Supported Scopes: country

remove_opinion_modifier - Removes a specific opinion modifier towards target country or any country from the scoped country
remove_opinion_modifier = { modifier = <key> who = <target (optional)> }
Supported Scopes: country

set_war_goal - Sets a war goal to the scoped rebel country/war
set_war_goal = { type = <key> target = <target> enemy = <target> }
Supported Scopes: country war

change_country_flag - Changes the scoped country's flag
change_country_flag = random
change_country_flag = { icon = { category = <key> file = <filename> } background = { category = <key> file = <filename> } colors = { <key> <key> } }
Supported Scopes: country

add_threat - Adds diplomatic threat from target country
add_threat = { who = <country> amount = 4/variable }
Supported Scopes: planet country galactic_object

set_mission - Sets the current mission of an observation station
set_mission = passive_observation
Supported Scopes: fleet

change_dominant_species - Changes the dominant species of the current Country, change_all also changes all usage of that species (Pops etc) in the empire
change_dominant_species = { species = target change_all = yes }
Supported Scopes: country

end_rivalry - Force-end rivalry with target country
end_rivalry = <target>
Supported Scopes: country

set_truce - Force a truce with target country of a specified type, or a war
set_truce = { target = <country/war> type = war/liberation/alliance/guarantee/none }
Supported Scopes: country

end_truce - Force-end truce with target country
end_truce = <target>
Supported Scopes: country

set_species_flag - Sets an arbitrarily-named flag on the scoped species
set_species_flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
Supported Scopes: species

set_timed_species_flag - Sets an arbitrarily-named flag on the scoped species for a set duration
set_timed_species_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: species

remove_species_flag - Removes a flag from the scoped species
remove_species_flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
Supported Scopes: species

auto_move_to_planet - Makes a fleet or ship auto-move to target planet
auto_move_to_planet = { target = <planet> clear_auto_move_on_arrival = yes }
Supported Scopes: ship fleet

remove_auto_move_target - Makes a fleet or ship stop auto-moving
remove_auto_move_target = yes
Supported Scopes: ship fleet

auto_follow_fleet - Makes a fleet or ship auto-move to target fleet and potentially attack it
auto_follow_fleet = { target = <fleet> attack_fleet = yes }
Supported Scopes: ship fleet

set_closed_borders - Changes closed borders status between two countries
set_closed_borders = {
	who = target
	status = yes/no
	forced = <int>/<variable> (number of years)
}
Supported Scopes: country

repair_percentage - Restores a certain percentage of hull points to the scoped ship or fleet
repair_percentage = 0.1
Supported Scopes: ship fleet

repair_armor_percentage - Restores a certain percentage of armor points to the scoped ship or fleet
repair_armor_percentage = 0.1
Supported Scopes: ship fleet

endgame_telemetry - Send endgame telemetry event
endgame_telemetry = ai_revolt
Supported Scopes: all

set_deposit - Replaces resource deposit on the scoped planet
set_deposit = <key/random>
Supported Scopes: planet

randomize_flag_symbol - Randomizes a country's flag symbol within the selected category
randomize_flag_symbol = pirate
Supported Scopes: country

add_claims - Adds claims on target system
add_claims = { who = <country> num_of_claims = x show_notification = no }
Supported Scopes: galactic_object

remove_claims - Removes claims on target system
remove_claims = { who = <country> num_of_claims = x }
Supported Scopes: galactic_object

create_military_fleet - Creates a military fleet with the designs of a specified country.
create_military_fleet = { owner = <target> scaled_size = 1.0 effect = { } }
Supported Scopes: all

guarantee_country - Makes a country guarantee another country
guarantee_country = <target>
guarantee_country = { target = <target> }
Supported Scopes: country

set_species_homeworld - Defines a homeworld for the current species.
set_species_homeworld = <target planet>
Supported Scopes: species

clear_resources - Clears resources of a country
clear_resources = yes
Supported Scopes: country

reroll_planet_modifiers - Rebuild modifiers on target planet
reroll_planet_modifiers = yes
Supported Scopes: planet

reroll_deposits - Rebuild resource deposits on target planet
reroll_deposits = yes
Supported Scopes: planet

delete_fleet - Deletes the target fleet (no death graphics)
delete_fleet = <target>
delete_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}
Supported Scopes: all

delete_dimensional_fleet - Deletes the target dimensional fleet
delete_dimensional_fleet = <target>
delete_dimensional_fleet = {
	target=<target>
}
Supported Scopes: all

add_trust - Adds trust on scope country towards target country
add_trust = { amount = <amount>/<variable> who = <target> }
Supported Scopes: country

add_tradition - Adds the specified tradition to the scoped country.
add_tradition = <tradition_key>
Supported Scopes: country

join_war - Joins wars on the side of target country
join_war = <target>
Supported Scopes: country

add_global_ship_design - Adds a specific global design to the game
add_global_ship_design = <target>
Supported Scopes: all

set_timed_leader_flag - Sets an arbitrarily-named flag on the scoped leader for a set duration
set_timed_leader_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: leader

set_species_identity - Sets the current species scopes identity to match the target scopes making them evaluate as the same species in is_same_species trigger.
set_species_identity = new/<target species>
Supported Scopes: species

pop_force_add_ethic - Adds a specific ethic to the scoped pop regardless if pop-species allows ethic divergence or not. 
pop_force_add_ethic = {
	ethic = <key>
	amount = <amount> OR percentage = <percentage>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: pop_group

set_empire_name - Sets the name of the current Empire.
set_empire_name = "name_loc_key"
Supported Scopes: country

set_empire_flag - Sets the flag of the current Empire.
set_empire_flag = <flag>
Supported Scopes: country

set_planet_name - Sets the name of the current planet.
set_planet_name = "name"
Supported Scopes: planet

set_fleet_formation - Sets a custom fleet formation on a fleet. 
set_fleet_formation = { position = { x = 1 y = 1 } position = { x = 2 y = 1 } }
Supported Scopes: fleet

create_message - Creates a message, can take multiple variables
create_message = { type = BYPASS_EXPLORED localization = BYPASS_EXPLORED_MESSAGE days = 30 (-1 is infinite) target = root  variable = { type = name localization = SYSTEM1 scope = from } variable = { type = name localization = SYSTEM2 scope = fromfrom } }
Supported Scopes: all

set_halted - Sets the mega structure upgrade to halted status for n days. -1 days = indefinitely
set_halted = nDays
Supported Scopes: megastructure

upgrade_megastructure_to - Starts an upgrade process on a mega structure. 
upgrade_megastructure_to = <new_type>
Supported Scopes: megastructure

set_planet_entity - Change entity of a planet.
set_planet_entity = {
	entity = <name of entity>
	graphical_culture = <target or name of culture>
	picture = <picture override>
	atmosphere_color = <color from 3 components>
	atmosphere_intensity = <0.0 - 1.0>
	atmosphere_width = <0.0 - 1.0> 
}
Supported Scopes: planet

remove_planet - Removes the planet from the scope 
remove_planet = yes
Supported Scopes: planet

set_megastructure_flag - Sets an arbitrarily-named flag on the scoped mega structure
set_megastructure_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure

set_timed_megastructure_flag - Sets an arbitrarily-named flag on the scoped mega structure for a set duration
set_timed_megastructure_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: megastructure

remove_megastructure_flag - Removes a flag from the scoped mega structure
remove_megastructure_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure

destroy_ship - Destroys the target ship (with death graphics)
destroy_ship = <target>
Supported Scopes: all

delete_ship - Deletes the target ship (no death graphics)
delete_ship = <target>
Supported Scopes: all

change_species - Changes the species of the scoped object
change_species = <target>
Supported Scopes: country ship pop pop_group leader army

change_leader_portrait - Changes the portrait of the leader in scope.
change_leader_portrait = <key or species event target>
Supported Scopes: leader

change_leader_class - Changes the class of the leader in scope.
change_leader_class = <leader class event target>
Supported Scopes: leader

resettle_pop - Instantly resettles pop
resettle_pop = { pop = <target pop> planet = <target planet> tile = <target tile> }
Supported Scopes: all

set_citizenship_type - Set citizenship type for scoped species/pop group/leader
set_citizenship_type = { country = <target> type = citizenship_full cooldown = yes }
Supported Scopes: pop pop_group leader species

set_military_service_type - Set military service type for scoped species/pop group/leader
set_military_service_type = { country = <target> type = military_service_full cooldown = yes }
Supported Scopes: pop pop_group leader species

set_purge_type - Set purge type for scoped species/pop group/leader
set_purge_type = { country = <target> type = purge_full cooldown = yes }
Supported Scopes: pop pop_group leader species

set_slavery_type - Set slavery type for scoped species/pop group/leader
set_slavery_type = { country = <target> type = slavery_livestock cooldown = yes }
Supported Scopes: pop pop_group leader species

set_population_controls - Set population control for scoped species/pop group/leader
set_population_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop_group leader species

set_migration_controls - Set migration control for scoped species/pop group/leader
set_migration_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop_group leader species

set_colonization_controls - Set colonization control for scoped species/pop group/leader
set_colonization_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop_group leader species

set_living_standard - Set living standard for scoped species/pop group/leader
set_living_standard = { country = <target> type = living_standard_good cooldown = yes }
Supported Scopes: pop pop_group leader species

shift_ethic - Shifts an empire towards a specific ethic, adjusting afterwards to keep number of ethics points consistent
shift_ethic = <key>
Supported Scopes: country

pop_change_ethic - Changes scoped pop to chosen ethic. 
pop_change_ethic = {
	ethic = <key>
	amount = <amount> OR percentage = <percentage>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: pop_group

clear_ethos - Clears all ethics of specified pop group or country
clear_ethos = yes
Supported Scopes: country pop pop_group

clear_planet_modifiers - Clear modifiers on target planet
clear_planet_modifiers = yes
Supported Scopes: planet

remove_all_armies - Removes all armies on scoped planet
remove_all_armies = yes
Supported Scopes: planet

mutate_species - Randomly mutate a species.
mutate_species = yes
Supported Scopes: species

rename_species - Renames the species.
rename_species = { 
	use one of the following:
	name = "an entry within the species name database"
	name = random
	name_list = "key"
}
Supported Scopes: species

reset_years_of_peace - Resets years of peace for a country.
reset_years_of_peace = yes
Supported Scopes: country

remove_secret_fealty - Removes a secret fealty pact between the scoped subject country and the target empire
remove_secret_fealty = <target>
Supported Scopes: country

clear_relations - Clears relations between scoped and target countries
clear_relations = {
	 target = <target country>
	 relations = { <> }
 }
Supported Scopes: country

set_agreement_terms - Sets agreement terms of the agreement. Can be used to set multiple terms at once, including resource subsidies.
set_agreement_terms = {
	subject_diplomacy = subject_can_not_do_diplomacy
	subject_integration = subject_can_be_integrated
	resource_subsidies_alloys = 0.5
}
Supported Scopes: agreement

set_agreement_preset - Sets the preset of an agreement and applies its terms on the agreement if 'apply_terms' is 'yes'.
set_agreement_preset = {
	preset = <preset key>
	apply_terms = no #Defaults to 'yes'
}
Supported Scopes: agreement

add_notification_modifier - Add a notification modifier to the country
add_notification_modifier = <key>
Supported Scopes: country

remove_notification_modifier - Remove a notification modifier to the country
remove_notification_modifier = <key>
Supported Scopes: country

set_city_graphical_culture - Sets the scoped country's city graphical culture
set_city_graphical_culture = <key>
Supported Scopes: country

set_player - Assign the player of the target country to play the scoped country instead
event_target:new_country = { set_player = event_target:old_country }
Supported Scopes: country

change_species_characteristics - Changes the characteristics of a species
change_species_characteristics = {
	sapient = <Y/N, determines if species is pre-sapient>
	immortal = <Y/N, determines if species leaders are immortal>
	can_be_modified = <Y/N, determines if the species can be modified>
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	portrait = <key/species/leader event target, limits >
	gender = <any/male/female/leader event target, limits species to this gender or removes limit if 'any'>
	can_change_leader = <Y/N, apply portrait and gender (randomizes new name) changes to existing leaders> 
Supported Scopes: species

copy_techs_from - Copies all techs from the target country to the scoped country, except for some exceptions listed. Tech weights (and weight modifiers) are honoured, meaning that techs a country should not have will not be copied.
copy_techs_from = { 
	target = country
	except = { tech_1 tech_2 }
}
Supported Scopes: country

create_bypass - Creates a bypass in the parent SpatialObject (stored in FromFrom), of the type passed in "type".
create_bypass = { owner = <target> type = <bypass type> effect = { <effects> } }
Supported Scopes: megastructure

activate_gateway - Activates the gateway associated with a megastructure.
activate_gateway = <target>
Supported Scopes: all

spawn_natural_wormhole - Spawns a new natural wormhole in the scoped system.
Use in_place_of instead of orbit_X / random_pos to use the location of an existing spatial object
spawn_natural_wormhole = { bypass_type = <wormhole/sealed_wormhole> orbit_distance = 100 orbit_angle = 90 random_pos = yes/no in_place_of = <target> (optional) graphics_entity_name = <entity> (optional) }
Supported Scopes: galactic_object

link_wormholes - Link the wormhole from the scoped system to the wormhole in the target system, or from the scope wormhole to the target wormhole.
link_wormholes = from
Supported Scopes: galactic_object bypass

spawn_astral_rift - Spawns a new astral rift in the scoped system.
If the id is not set or equal to none, spawns a random rift from the pool once exploration begins.
Can be spawned relatively to an existing spatial object, tolerance is applied to the angle to avoid already existing planets.
spawn_astral_rift = { random_pos = yes/no (default = no, exclusive with relative_to and in_place_of) orbit_distance = 100 orbit_angle = 360 id = astral_rift_key/none (optional) relative_to = target (optional) tolerance = (optional) in_place_of = spatial_object (optional) graphics_entity_name = entity (optional) spawn_sound = yes/no (default = yes) init_effect = {} }
Supported Scopes: galactic_object

destroy_astral_rift - Destroys target Astral Rift
destroy_astral_rift = <target>
Supported Scopes: all

create_starbase - Creates a starbase in orbit of the star of the scoped galactic object
create_starbase = {
	owner = <target>
	size = <ship_size>
	design=<starbase global design>s
	module = <starbase_module>
	building = <starbase_building>
	effect = { ... }
}
Supported Scopes: planet galactic_object

set_starbase_size - Sets the ship size of a starbase
set_starbase_size = <ship_size>
Supported Scopes: starbase

set_starbase_module - Sets a module in a slot on a starbase
set_starbase_module = { slot = <int> module = <starbase_module> }
Supported Scopes: starbase

set_starbase_building - Sets a building in a slot on a starbase
set_starbase_building = { slot = <int> building = <starbase_building> }
Supported Scopes: starbase

remove_starbase_module - Removes a module from a certain slot or all slots on a starbase
remove_starbase_module = { slot = <int> (optional, default = all) module = <starbase_module> (optional) }
Supported Scopes: starbase

remove_starbase_building - Remove a building from a certain slot or all slots on a starbase
remove_starbase_building = { slot = <int> (optional, default = all) building = <starbase_building> (optional) }
Supported Scopes: starbase

add_casus_belli - Adds a Casus Belli to the scoped country against the target country.
add_casus_belli = { type = cb_subjugation who = <country> days = 10/variable }
Supported Scopes: country

get_galaxy_setup_value - Copies a value from the galaxy setup into a variable, optionally scaling it by an int value
get_galaxy_setup_value = { which = <string> setting = <string> [ scale_by = <float> ] }
possible values: num_empires, num_advanced_empires, num_fallen_empires, num_marauder_empires, mid_game_year, end_game_year, victory_year, num_guaranteed_colonies, num_gateways, num_wormhole_pairs, num_hyperlanes, habitable_worlds_scale, primitive_worlds_scale, crisis_strength_scale, tech_costs_scale
Supported Scopes: all

finish_upgrade - Finish the current upgrade of a Mega Structure.
finish_upgrade = yes
Supported Scopes: megastructure

effect_on_blob - Executes an effect on systems with planets owned by the scoped country, starting at an origin, and until a certain percentage of owned planets matching the planet_limit has been covered.
effect_on_blob = {
	center = <system target>
	owned_planets_percentage = 1.0/variable
	planet_limit = { <planet triggers> }
	effect = { <system effects> }
}
Supported Scopes: country

add_seen_bypass_type - Makes the scoped country remember that it has encountered the bypass type
add_seen_bypass_type = bypass_type
Supported Scopes: country

add_seen_bypass - Makes the scoped country remember that it has encountered the bypass 
add_seen_bypass = FROM
Supported Scopes: country

set_fleet_bombardment_stance - Sets the bombardment stance of the scoped fleet
set_fleet_bombardment_stance = selective
Supported Scopes: fleet

check_casus_belli_valid - Re-evaluate the specified casus belli type with given target country
check_casus_belli_valid = {
	target = none/<optional country target>
	type = <optional casus belli type>
}
Supported Scopes: country

copy_ethos_and_authority - Makes the scoped country copy the ethos and government authority of the target country.
copy_ethos_and_authority = FROM
Supported Scopes: country

clone_leader - Clones the last created leader for the scoped country
clone_leader = {
	target = <event target>
	#Properties to override, see create_leader
	#traits is only overridden if the override is not empty
	#randomize_traits is only used if traits is overridden
	#If traits is not overridden, trait picks are also copied
	effect = { ... }
}
Supported Scopes: country

set_home_base - Set the home base of the scoped fleet to the specified starbase
set_home_base = event_target:cool_starbase
Supported Scopes: fleet

add_hyperlane - Adds a hyperlane between two systems
add_hyperlane = { from = <system> to = <system> }
Supported Scopes: all

remove_hyperlane - Removes existing hyperlane between two systems
remove_hyperlane = { from = <system> to = <system> }
Supported Scopes: all

else_if - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
if = { limit = { <triggers> } <effects> }
else_if = { limit = { <triggers> } <effects> }
Supported Scopes: all

create_saved_leader - Creates a new saved leader for the scoped country with a lookup key. See create_leader for parameters.
create_saved_leader = {  }
Supported Scopes: country

remove_saved_leader - Removes a saved leader for the scoped country with a lookup key
remove_saved_leader = <string>
Supported Scopes: country

activate_saved_leader - Moves a saved leader to the active for the scoped country with a lookup key
activate_saved_leader = {
	key = <string>
	add_to_owned=<yes/no> #default yes
	effect = {...}
}
Supported Scopes: country

add_relic - Adds the specified relic to the scoped country.
add_relic = <relic_key>
Supported Scopes: country

remove_relic - Removes the specified relic from the scoped country.
remove_relic = <relic_key>
Supported Scopes: country

delete_megastructure - Deletes the target mega structure (no death graphics)
delete_megastructure = <target>
Supported Scopes: all

add_random_research_option - Adds a random tech research option to the scoped country's tech view list, permanent until researched. if none applicable it runs fail_effects
add_random_research_option = {
	category = <string>
	area = <key>
	tier = <int>
	add_progress = <num>/<variable>
	ignore_prereqs = <yes/no> #default no
	ignore_rare = <yes/no> #default yes
	only_rare = <yes/no> #default no
	ignore_insight = <yes/no> #default yesyes
	fail_effects = {}
}
Supported Scopes: country

copy_random_tech_from - Adds a random tech from the target country within the given category and tech area constraints. The country must be able to research said tech (weight > 0, fulfils potential trigger)
copy_random_tech_from = {
	who = <country>
	category = computing (optional)
	area = physics (optional)
	progress = 0.5/variable (optional: this makes it grant the tech option rather than the whole tech)
}
Supported Scopes: country

add_asteroid_belt - Adds an asteroid belt at the distance in the scope.
add_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}
Supported Scopes: galactic_object

set_asteroid_belt - Sets an asteroid belt at the distance in the scope.
set_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}
Supported Scopes: galactic_object

fleet_action_research_special_project - Sends a fleet to research a special project
fleet_action_research_special_project = { special_project = test_project target = event_target:project_planet }
Supported Scopes: fleet

remove_random_district - Removes a random district from the scoped planet. Bigger district is more likely to be removed.
remove_random_district = yes
Supported Scopes: planet

remove_all_districts - Removes all districts from the scoped planet
remove_all_districts = yes
Supported Scopes: planet

remove_district - Removes a specific district from the scoped planet
remove_district = <key>
Supported Scopes: planet

add_district - Begins construction of a specific district on the scoped planet
add_district = <key>
or
add_district = {
	district_type = <key>
	ignore_cap = <yes/no> #default no
	type_conversion = <yes/no> #default no
}
Supported Scopes: planet

enable_on_market - Enables a resource on the Galactic Market
enable_on_market = <resource_key>
Supported Scopes: all

enable_galactic_market - Enables the galactic market.
enable_galactic_market = <yes/no> 
Supported Scopes: country

add_timed_trait - Adds a specific trait to the scoped leader for a specific duration
add_timed_trait = { trait = <trait> days/months/years = <value>/<variable> }
Supported Scopes: leader

set_planetary_ascension_tier - Sets the planet's ascension tier to the specified value
set_planetary_ascension_tier = 3
Supported Scopes: planet

create_archaeological_site - Creates a archaeological site associated with the scope object
create_archaeological_site = <site type>
Supported Scopes: megastructure planet ship fleet galactic_object ambient_object starbase debris astral_rift

destroy_archaeological_site - Destroys a archaeological site in right hand site event target
destroy_archaeological_site = <event target>
Supported Scopes: all

add_starbase_component - Adds a ship component to a starbase, standalone from any module or building
add_starbase_component = { component = <component key> }
Supported Scopes: starbase

remove_starbase_component - Removes the specified ship component to a starbase. Only works for components that are standalone from any module or building.
remove_starbase_component = { component = <component key> }
Supported Scopes: starbase

add_stage_clues - Adds clues to the current stage of an archaeological or first contact site
add_stage_clues = <int>
Supported Scopes: archaeological_site first_contact astral_rift

add_expedition_log_entry - Adds a specific expedition log entry to an archaeological site chapter
add_expedition_log_entry = {
	title = <loc key>
	tooltip = <loc key>
}
Supported Scopes: archaeological_site

reset_current_stage - Resets the current stage
reset_current_stage = yes/no
yes = also randomize new difficulty if stage allows that.
no = does not change difficulty
Supported Scopes: archaeological_site

set_current_stage - Sets the current stage for this arc site (first chapter is index 0).
set_current_stage = <stage number>
Supported Scopes: archaeological_site

finish_current_stage - Finish the current stage
finish_current_stage = yes/no/<country>
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
country = use this country instead of excavator, no stage complete will be triggered.
Supported Scopes: archaeological_site

finish_site - Finish the whole archaeological site
finish_site	 = yes/no/<country>
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
country = use this country instead of excavator, no stage complete will be triggered.
Supported Scopes: archaeological_site

set_site_progress_locked - Locks or unlocks the progress of a site
set_site_progress_locked = yes/no
Supported Scopes: archaeological_site first_contact

advanced_authority_refresh - Used after an advanced authority swap to make sure things are changed properly
advanced_authority_refresh = yes
Supported Scopes: country

custom_tooltip_with_params - Displays a specific localization string with parameters in tooltip
custom_tooltip_with_params = {
	description = <loc key>
	description_parameters = {
		<value key> = <string/int/num/bool>
	}
}
Supported Scopes: all

set_federation_law - Sets the given law for the scoped federation
set_federation_law = <federation law>
Supported Scopes: federation

add_to_galactic_community - Tries to add the scoped country to the Galactic Community
add_to_galactic_community = yes/no
Supported Scopes: country

add_to_galactic_community_no_message - Tries to add the scoped country to the Galactic Community without producing member joining notifications.
add_to_galactic_community_no_message = yes/no
Supported Scopes: country

remove_from_galactic_community - Tries to remove the scoped country from the Galactic Community
remove_from_galactic_community = yes/no
Supported Scopes: country

add_to_galactic_council - Tries to add the scoped country to the Galactic Council
add_to_galactic_council = yes/no
Supported Scopes: country

remove_from_galactic_council - Tries to remove the scoped country from the Galactic Council
remove_from_galactic_council = yes/no
Supported Scopes: country

steal_relic - Steal all/a random/a specific relic from a target country
steal_relic = { target = <Target Country> relic = <relic_name/all/random>
Supported Scopes: country

country_list_tooltip - Prints a list of the countries that match the limit triggers in a tooltip, each separated by a line break.
country_list_tooltip = { limit = { <triggers> } }
Supported Scopes: all

owned_planet_list_tooltip - Prints a list of the country's planets that match the limit triggers in a tooltip, each separated by a line break.
owned_planet_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_pop_faction_list_tooltip - Prints a list of the country's pop factions that match the limit triggers in a tooltip, each separated by a line break.
owned_pop_faction_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_leader_list_tooltip - Prints a list of the country's leaders that match the limit triggers in a tooltip, each separated by a line break.
owned_leader_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_fleet_list_tooltip - Prints a list of the country's fleets that match the limit triggers in a tooltip, each separated by a line break.
owned_fleet_list_tooltip = { limit = { <triggers> } divider_tooltip = localisation }
Supported Scopes: country

set_cooldown - Locks the leader in its current role for the next X days.
set_cooldown = int
Supported Scopes: leader

add_federation_experience - Adds experience to the scoped federation
add_federation_experience = <federation experience>
Supported Scopes: federation

set_federation_type - Sets federation type to the scoped federation
set_federation_type = <federation type>
Supported Scopes: federation

set_federation_succession_type - Sets scoped federation's succession type to the specified value. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_succession_type = <federation succession type>
Federation succession types: strongest/diplomatic_weight/rotation/challenge/random
Supported Scopes: federation

set_federation_succession_term - Sets scoped federation's succession term to the specified value. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_succession_type = <federation succession term>
Federation succession terms: status_change/years_10/years_20/years_30/years_40
Supported Scopes: federation

set_only_leader_builds_fleets - Sets exclusive right to build fleets by federation leader. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_only_leader_builds_fleets = <yes/no>
Supported Scopes: federation

set_allow_subjects_to_join - Sets right for subjects to join federation. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_allow_subjects_to_join = <yes/no>
Supported Scopes: federation

set_equal_voting_power - Sets different voting weight. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_equal_voting_power = <yes/no>
Supported Scopes: federation

set_diplomacy_action_setting - Sets diplomatic action custom setting. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_diplomacy_action_setting = {
	action = <action_key>
	settings = { vote_type = default }
}
Supported Scopes: federation

set_free_migration - Sets unified migration flag for federation. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_free_migration = <yes/no>
Supported Scopes: federation

set_federation_settings - Sets diplomatic action custom setting. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_settings = {
	<setting> = <value>
	...
}
Supported Scopes: federation

add_associate_member - Add specified country as an associate member
add_associate_member = { who = <target> override_requirements = yes/no }
Supported Scopes: federation

remove_associate_member - Removes a specific associate member from the federation
remove_associate_member = { who = <country> override_requirements = yes/no }
Supported Scopes: federation

add_cohesion - Add cohesion to the federation
add_cohesion = <value>
Supported Scopes: federation

set_council_size - Sets the number of seats on the Galactic Council
set_council_size = <int>
Supported Scopes: all

increase_council_size - Increases the number of seats on the Galactic Council by 1
increase_council_size = yes/no
Supported Scopes: all

decrease_council_size - Decreases the number of seats on the Galactic Council by 1
decrease_council_size = yes/no
Supported Scopes: all

set_council_veto - Sets whether council members can veto resolutions or not
set_council_veto = yes/no
Supported Scopes: all

set_council_emergency_measures - Sets whether council members can propose emergency measures or not
set_council_emergency_measures = yes/no
Supported Scopes: all

add_permanent_councillor - Gives provided country a permanent position on the Galactic Council
add_permanent_councillor = yes/no
Supported Scopes: country

remove_permanent_councillor - Remove the provided country from their permanent council position
remove_permanent_councillor = yes/no
Supported Scopes: country

add_loyalty - Add loyalty to subject of an agreement
add_loyalty = 5
Supported Scopes: agreement

set_sector_capital - Sets the scoped planet to be the capital of the sector it is part of. If used in the capital sector, it will shift the empire capital. Warning: Experimental, may have unintended consequences.
set_sector_capital = yes
Supported Scopes: planet

set_colony_type - Sets the colony's designation type
set_colony_type = <colony type>
Supported Scopes: planet

set_male_ruler_title - Sets the country's male ruler title to a custom value
set_male_ruler_title = "Grand Executioner"
Supported Scopes: country

set_female_ruler_title - Sets the country's female ruler title to a custom value
set_female_ruler_title = "Grand Executionerress"
Supported Scopes: country

set_male_heir_title - Sets the country's male heir title to a custom value
set_male_heir_title = "Little Executioner"
Supported Scopes: country

set_female_heir_title - Sets the country's female heir title to a custom value
set_female_heir_title = "Little Executioneress"
Supported Scopes: country

clear_custom_ruler_and_heir_titles - Clears all custom ruler and heir titles from the country, resetting them to default values
clear_custom_ruler_and_heir_titles = yes
Supported Scopes: country

complete_special_project - Completes a specific special project for the country, firing the on complete effects
complete_special_project = { type = <project key> location = <target> }
Supported Scopes: country

set_government_cooldown - Locks the country's government for a given period of days, the default cooldown, or unlocks it.
set_government_cooldown = 500/default/no
Supported Scopes: country

change_colony_foundation_date - Changes the colony foundation date (affecting on_colony_X_years pulses) by a specific number of days. Use with care, you can probably break things with this!
change_colony_foundation_date = <+/- int>
Supported Scopes: planet

log_error - Prints a message to error.log for debugging purposes.
Supported Scopes: all

add_intel - Adds the defined amount of intel toward the target empire
add_intel = { amount = <float>/<variable> who = <target> }
Supported Scopes: country

fire_on_action - Fires a made-up on_action.
fire_on_action = { on_action = <string> scopes = { from = X fromfrom = Y } }
Supported Scopes: all

set_first_contact_stage - Sets the given stage for the scoped first contact
set_first_contact_stage = <stage name>
Supported Scopes: first_contact

finish_current_operation_stage - Finish the current operation phase
finish_current_operation_stage = yes/no
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
Supported Scopes: espionage_operation

set_mia - Sets the current fleet to go missing in action with the MIA type defided by <key>
set_mia = <key>
Supported Scopes: fleet

set_mia_return_delay - If the scoped fleet is MIA, sets the return date in a given number of days, starting from current date
set_mia_return_delay = <int>
Supported Scopes: fleet

create_espionage_asset - Creates espionage asset within a given spy network
create_espionage_asset = {
	type = <espionage asset type>
	effect = { <effects executed on asset> }
}
Supported Scopes: spy_network

destroy_espionage_asset - Destroys espionage asset within a given spy network/operation
destroy_espionage_asset = <espionage asset type>
Supported Scopes: spy_network espionage_operation

set_espionage_operation_progress_locked - Locks or unlocks the progress of an espionage operation
set_espionage_operation_progress_locked = yes/no
Supported Scopes: espionage_operation

unassign_espionage_asset - Unassigns espionage asset from the scope operation to owning spy network
unassign_espionage_asset = <espionage asset type>
Supported Scopes: espionage_operation

assign_espionage_asset - Assigns espionage asset to the scope operation from owning spy network
assign_espionage_asset = <espionage asset type>
Supported Scopes: espionage_operation

set_espionage_operation_flag - Sets an arbitrarily-named flag on the scoped espionage operation
set_espionage_operation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_operation

remove_espionage_operation_flag - Removes a flag from the scoped espionage operation
remove_espionage_operation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_operation

set_design_flag - Sets an arbitrarily-named flag on the scoped design
set_design_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: design

remove_design_flag - Removes a flag from the scoped design
remove_design_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: design

complete_crisis_objective - Gives the player the reward for the specified crisis objective, if the player's selected crisis path includes it. Gives nothing if the player's crisis path doesn't include it. 
complete_crisis_objective = <objective>
Supported Scopes: country

start_situation - Begins a situations.
start_situation = { type = <situation_type> target = <scope> }
Supported Scopes: country

espionage_operation_event - Fires a espionage event event for the scoped object, with optional DAYS and RANDOM delay
espionage_operation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: espionage_operation

join_war_on_side - Joins the war on the specified side.
join_war_on_side = { war = <target> side = attackers/defenders/<country> }
Supported Scopes: country

dissolve_federation - Dissolved the current federation
dissolve_federation = yes
Supported Scopes: federation

remove_random_starbase_building - Remove a number of random building(s) matching/not matching a type from the starbase
remove_random_starbase_building = {
	type = <starbase building> ( optional. default: all )
	count = <int> (optional. default: 1 )
}
Supported Scopes: starbase

remove_random_starbase_module - Remove a number of random module(s) matching/not matching a type from the starbase
remove_random_starbase_module = {
	type = <starbase module> ( optional. default: all )
	count = <int> (optional. default: 1 )
}
Supported Scopes: starbase

set_timed_espionage_operation_flag - Sets an arbitrarily-named flag on the scoped espionage operation for a set duration
set_timed_espionage_operation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: espionage_operation

destroy_espionage_operation - Destroys a espionage operation site in right hand site event target
destroy_espionage_operation = <event target>
Supported Scopes: all

add_espionage_information - Adds information to the current stage of an espionage operation
add_espionage_information = <value>
Supported Scopes: espionage_operation

add_victory_score - Adds victory score to a country
add_victory_score = { source=<loc_key> score=<value>/<variable> }
Supported Scopes: country

activate_crisis_progression - Activates crisis progression for the country
activate_crisis_progression = <path_name>.
Supported Scopes: country

room_name_override - Sets the room background of the empire. Provide an empty string to remove the override.
room_name_override = <room_name>
Supported Scopes: country

set_ai_personality - Sets the AI personality of a country to a new one
set_ai_personality=<personality>
Supported Scopes: country

add_custodian_term_days - Increase the current Custodian term time
add_custodian_term_days = <days>
Supported Scopes: all

set_custodian_term_days - Set the current Custodian term time. -1 will make the Custodianship permanent.
set_custodian_term_days = <days>
Supported Scopes: all

destroy_situation - Destroys a situation in right hand side event target, use once situation is complete (on_fail/on_complete/on_abort is not called)
destroy_situation = <event target>
Supported Scopes: all

abort_situation - Destroys a situation in right hand side event target, firing on_abort (use to cancel and fire that effect)
abort_situation = <event target>
Supported Scopes: all

add_situation_progress - Adds a sum of progress scoped situation
add_situation_progress = 5.5
Supported Scopes: situation

set_situation_approach - Sets the approach to the Situation. Respects allow and potential triggers.
set_situation_approach = <approach> (name field of the approach)
Supported Scopes: situation

set_situation_locked - Locks the Situation so it will not progress until unlocked.
set_situation_locked = yes/no (no unlocks it)
Supported Scopes: situation

change_situation_target - Changes the target of a Situation.
change_situation_target = none/scope
Supported Scopes: situation

pass_targeted_resolution - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type that has the specified target. Ignores whether the target is valid or not.
pass_targeted_resolution = { resolution = <resolution type> target = <target>
Supported Scopes: country

set_update_modifiers_batch - Disables modifier system to do full updates between Begin and End.
On end it will trigger a full update of any dirty modifiers.
Begin: set_update_modifiers_batch = begin
End: set_update_modifiers_batch = end
Supported Scopes: all

set_rule_can_subject_be_integrated - Changes the agreement term for whether the Subject can be integrated
set_rule_can_subject_be_integrated = <yes/no>
Supported Scopes: agreement

set_rule_can_subject_do_diplomacy - Changes the agreement term for whether the Subject can do diplomacy
set_rule_can_subject_do_diplomacy = <yes/no>
Supported Scopes: agreement

set_rule_can_subject_expand - Changes the agreement term for whether the Subject can expand
set_rule_can_subject_expand = <can_expand/can_expand_with_tithe/cannot_expand>
Supported Scopes: agreement

set_rule_can_subject_vote - Changes the agreement term for whether the Subject can vote independently of its overlord in GalCom/federations
set_rule_can_subject_vote = <yes/no>
Supported Scopes: agreement

set_rule_join_overlord_wars - Changes the agreement term for Subject to join Overlord wars
set_rule_join_overlord_wars = <none/defensive/offensive/all>
Supported Scopes: agreement

set_rule_join_subject_wars - Changes the agreement term for Overlord to wars of its Subject
set_rule_join_subject_wars = <none/defensive/offensive/all>
Supported Scopes: agreement

set_rule_subject_has_access - Changes the agreement term for whether the Subject can access the overlord's territory (and territories the overlord has access to) despite closed borders
set_rule_subject_has_access = <yes/no>
Supported Scopes: agreement

set_rule_subject_has_sensors - Changes the agreement term for whether the Subject gets sensors data from Overlord
set_rule_subject_has_sensors = <yes/no>
Supported Scopes: agreement

convert_to_specialist - Starts the process of converting the subject of the scoped agreement to the given specialist type.
Can also be used to remove the specialization from a subject, by using 'none' as value.
convert_to_specialist = <specialist_subject_type>
Supported Scopes: agreement

pass_debris_ownership - Passes the scoped debris ownership to the specified country 
pass_debris_ownership = { owner = <target country> }
Supported Scopes: debris

set_council_position - Sets the scoped leader to a council position if it is present in the government of the leader's owner country.
set_council_position = COUNCIL_POS_KEY
Supported Scopes: leader

set_council_position_to_council - Assigns a council position to the country's council, if possible.
set_council_position_to_council = COUNCIL_POS_KEY
Supported Scopes: country

end_fleet_contract - Breaks fleet lease contract 
end_fleet_contract = yes
Supported Scopes: fleet

set_cloaking_active - Sets current fleet's cloaking status
set_cloaking_active = yes|no
Supported Scopes: fleet

go_to_next_pre_ftl_age - Advances country to next pre-FTL technology level if possible. Does nothing if has_next_pre_ftl_age would be false, or if argument is 'no'.
go_to_next_pre_ftl_age = <yes/no>
Supported Scopes: country

set_pre_ftl_age - Set pre-FTL technology level. Does nothing if the country is not pre-FTL.
set_pre_ftl_age = <age>
Supported Scopes: country

remove_communications - Remove communications between scoped country and target country
remove_communications = <target>
Supported Scopes: country

remove_envoys_to - Removes any envoys from scoped country assigned to target country
remove_envoys_to = <country>
Supported Scopes: country

remove_from_federation - The scoped country is removed from any federation its in
remove_from_federation = yes
Supported Scopes: country

set_ship_design - Changes which design a ship uses/all ships in a fleet use, to the target design
set_ship_design = {
  design = <ship design key/target/last_created_design, or use random_existing_design>
  random_existing_design = <ship size key>
}
Supported Scopes: ship fleet

renew_bypass_lock - Renew a Bypass Lock's duration as if it was just built.
renew_bypass_lock = yes
Supported Scopes: bypass

lock_bypass - Lock a Bypass for exclusive access for a given country.
lock_bypass = { country = owner duration = 360 }
Supported Scopes: bypass

date_distortion - Enables or disables the date distortion effect
date_distortion = yes
Supported Scopes: all

refresh_portraits - Signals to portrait objects that they need to refresh some of their properties
	refresh_portraits = planet/room/character/all
Supported Scopes: country

start_astral_action_cooldown - Starts the cooldown of an astral action defined with uses_custom_cooldown = yes
start_astral_action_cooldown=<key>
Supported Scopes: country

perform_astral_action_unlock_check - Unlocks Astral Actions that have become unlockable since the last time this effect was called.
perform_astral_action_unlock_check = yes
Supported Scopes: country

activate_fog_machine - Creates cloud effect at every star system controlled by the country
activate_fog_machine = <cloud_type>
Supported Scopes: country

deactivate_fog_machine - Deactivates country fog machine
deactivate_fog_machine = yes
Supported Scopes: country

fog_machine_auto_tracking - Switches on/off galactic object ownership auto tracking for country fog machine
fog_machine_auto_tracking = yes/no
Supported Scopes: country

create_cosmic_storm - Creates a cosmic storm
storm_start_position = <target>
storm_end_position = <target>
storm_min_radius = <value>
storm_max_radius = <value>
storm_max_range = <value>
type = <string>
Supported Scopes: all

destroy_cosmic_storm - Destroy the scoped storm.
Supported Scopes: cosmic_storm

cosmic_storm_event - Fires a storm event for the scoped storm
storm_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: cosmic_storm

cosmic_storm_influence_field_event - Fires a storm event for the scoped storm influence field
storm_influence_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: cosmic_storm_influence_field

set_auto_upgrade_components - Sets wether or not the design automatically upgrades its components.
set_auto_upgrade_components = yes
Supported Scopes: design

spawn_random_storm - Spawn a random storm type with a random start and end position
Supported Scopes: all

create_cosmic_storm_influence_field - Creates a storm influence field in a certain radius
radius = <float>
Supported Scopes: planet starbase

destroy_cosmic_storm_influence_field - Destroys a storm influence field with center
 center = <target>
Supported Scopes: planet starbase

recalculate_storm_influence_field - Recalculates the influence for each system in an influence field
Supported Scopes: cosmic_storm_influence_field

set_fauna_fleet_growth_stance - Sets Space Fauna growth stance. Setting to 'none' resets stance to use default country policy.
set_fauna_fleet_growth_stance = <value> (controlled/excessive/none)
Supported Scopes: country fleet

start_storm_area_placing - Starts the storm placing mode with radius 
radius = <float> 
Supported Scopes: all

give_specimen - Gives a given specimen to the target country.
give_specimen = { key = <specimen> origin = <key> }
Supported Scopes: country

remove_specimen - Removes specified specimen from the target country.
remove_specimen = <specimen>
Supported Scopes: country

set_emergency_fund_active - Sets whether the emergency fund should be active or not.
Supported Scopes: all

storm_apply_aftermath_modifier - Applies Cosmic Storm Aftermath Modifiers. You can specify up to a max of 10 Severities and each one will be chosen based on it's chance.
storm_apply_aftermath_modifier = { severity = { modifier = <key>, days = <ModifierDuration> chance = <WeightedChance> effect  = <OnAppliedOptionalEffect> }}
Supported Scopes: all

set_cosmic_storm - Sets a storm on a system
 cosmic_storm = <target>
Supported Scopes: galactic_object

unset_cosmic_storm - Unsets a storm on a system
Supported Scopes: galactic_object

set_emergency_fund_contribution_rate - Sets rate for contributions to the emergency fund.
Supported Scopes: all

finish_council_agenda - Tries to finish the current council agenda for the scoped country
finish_council_agenda = yes/no
Supported Scopes: country

add_mission_counter - Increments (or decrements with negative values) a mission counter for the scoped country by a specific amount
add_mission_counter = { mission = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

set_storm_flag - Sets an arbitrarily-named flag on the scoped cosmic storm.
set_storm_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: cosmic_storm

set_mission_counter - Sets a mission counter for the scoped country to a specific amount
set_mission_counter = { mission = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

stop_mission - Stops the mission with the given status, triggering the relevant effects.
 stop_mission = { mission = <mission_key> status = success }
Supported Scopes: planet country ship pop pop_group

give_culling_rewards - Gives associated culling rewards from a space fauna design to the target country.
give_culling_rewards = { design = <key> }
Supported Scopes: country

give_dna - Gives given space fauna DNA with given rarity to the target country.
give_dna = { ship_category = <key> rarity = <key> (optional) }
Supported Scopes: country

add_to_vivarium - Gives Space Fauna in the Vivarium using given ship design with given rarity to the target country.
add_to_vivarium = { design = <key> rarity = <key>/highest (optional) amount = <int> (optional) }
Supported Scopes: country

reanimate_space_fauna - Reanimates Space Fauna ship(s) back to life in zombie form.
reanimate_space_fauna = {
	fleet = <fleet>
}
Supported Scopes: ship debris

spawn_custom_debris - Spawns a custom debris project with the current fleet.
	for = <country> - country to give the debris project to.
	should_add_ship_to_debris = trigger (optional) - used to check if the ship must be added to the debris.
	must_scavenge/must_research = yes/no (default no) - used to specify and override country behaviour towards this debris.
	reset_killed_ship_designs = yes/no (default no) - used to force the fleet to reset its killed ships designs.
Supported Scopes: fleet

select_decision - Selects a decision on a planet
Supported Scopes: planet

return_leader_from_exile - Returns the leader from a custom name
return_leader_from_exile = <key>/<key@scope>
Supported Scopes: country

kill_exiled_leader - Kills the scoped leader saved with a custom name
kill_exiled_leader = <key>/<key@scope>
Supported Scopes: country

lock_storm_in_place - If yes, locks a Cosmic Storm in place. If no, it advances again at its normal speed.
Supported Scopes: cosmic_storm

set_ship_construction_type - Set scoped starbase's current construction type
set_ship_construction_type = <starbase_type/none>
Supported Scopes: starbase

link_to - Link the scoped megastructure bypass to the given target megastructure bypass.
set_linked_to = from
Supported Scopes: megastructure

steal_specimens - Steals random specimens from given country.
steal_specimens = { who = <country> category = <category_key>/all/any count = <int>show_nofication = <yes/no> }
Supported Scopes: country

release_vivarium_fauna - Releases into the wild space fauna contained in the scoped country's Vivarium, from all or given ship category.	Resulting fleet owner can be specified.	Space Fauna can be culled for resources instead by specifying 'cull_vivarium_critter = yes'.release_vivarium_fauna = { category = <ship_category>/all location = <target> owner = <country>cull_vivarium_critter = <yes/no> }
Supported Scopes: country

release_vivarium_fauna_count - Releases into the wild a specific amount of space fauna contained in the scoped country's Vivarium.Rarest fauna is released in priority.	Resulting fleet owners can be specified.	release_vivarium_fauna_count = { count = <capacity_to_release> location = <target> owners = { <category> = <country> } }
Supported Scopes: country

create_smaller_size_creature_in_fleet - Creates new creatures of the smaller ship size in the same fleet
create_smaller_size_creature_in_fleet = <value>
Supported Scopes: ship

integrate_species - Triggers the sub-species integration step for a country.
integrate_species = yes 
Supported Scopes: country

repair_shield_percentage - Restores a certain percentage of shield points to the scoped ship or fleet
repair_shield_percentage = 0.1
Supported Scopes: ship fleet

repair_amount - Restores a certain amount of hull points to the scoped ship or fleet
repair_amount = 10.0
Supported Scopes: ship fleet

repair_armor_amount - Restores a certain amount of armor points to the scoped ship or fleet
repair_armor_amount = 10.0
Supported Scopes: ship fleet

repair_shield_amount - Restores a certain amount of shield points to the scoped ship or fleet
repair_shield_amount = 10.0
Supported Scopes: ship fleet

set_faction_needs_colony - Sets if a country needs a colony (or a colony ship) to be considered alive
set_faction_needs_colony = yes
Supported Scopes: country

set_faction_auto_delete - Sets if country will be automatically deleted when considered dead
set_faction_auto_delete = yes
Supported Scopes: country

copy_traditions_from - Copies the traditions of the target country into the scoped country. Traditions are added to the existing traditions, and the potential/possible triggers are respected.the traditions listed in the exceptions list are not copied.
copy_traditions_from = {
    target = FROM
    exceptions = { tradition1 tradition2 }
}
Supported Scopes: country

copy_ascension_perks_from - Copies the Ascension Perks of the target country into the scoped country. Perks are added to the existing perks, and the potential/possible triggers are respected.the perkss listed in the exceptions list are not copied.
copy_ascension_perks_from = {
    target = FROM
    exceptions = { perk1 perk2 }
}
Supported Scopes: country

remove_tradition - Remove the target tradition from the scoped Country.
remove_tradition = tradition_key
Supported Scopes: planet country ship pop pop_group

remove_tradition_tree - Remove the target tradition tree from the scoped Country.
remove_tradition_tree = tradition_category_key
Supported Scopes: planet country ship pop pop_group

add_ascension_perk - Adds the specified ascension perk to the scoped country.
add_ascension_perk = ascension_perk_key
Supported Scopes: country

remove_ascension_perk - Remove the target ascension perk from the scoped Country.
remove_ascension_perk = ascension_perk_key
Supported Scopes: planet country ship pop pop_group

add_focus_progress - Adds the defined amount of focus progress in the defined focus category
add_focus_progress = { category = <focus_category_key> amount = <float>/<variable> }
Supported Scopes: country

add_pop_amount - Adds the amount of pops to the scope pop group.
	add_pop_amount = <num>
OR
	add_pop_amount = {
		amount = <number>
		random = <number> The amount will be randomized in [max(0, size - random), size + random].
	}
Supported Scopes: pop_group

remove_pop_amount - Removes the amount of pops from the scope pop group.
	remove_pop_amount = <num>
OR
	remove_pop_amount = {
		amount = <number>
		random = <number> The amount will be randomized in [max(0, size - random), size + random].
	}
Supported Scopes: pop_group

scale_pop_amount - Scales the amount of pops in the scope pop group
scale_pop_amount = <value>
Supported Scopes: pop_group

transfer_pop_amount - Transfer the amount OR percentage of pops from the source pop group to the target pop group
transfer_pop_amount = {
	source = <source pop group>
	target = <target pop group>
	amount = <amount> OR percentage = <percentage>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: all

set_habitability_trait - Set planet preference trait for scoped species (removing the current one, if any).
set_habitability_trait = { trait = <trait> }
Supported Scopes: species

set_confused - Sets the confusion state on the target ship/fleet (all ships). Clears at the end of combat.
set_confused = yes/no
Supported Scopes: ship fleet

add_growth - Adds a specific amount of growth (non-fauna ships)
add_growth = 120
Supported Scopes: ship fleet

reset_growth - Resets growth to zero (non-fauna ships)
reset_growth = {}
Supported Scopes: ship fleet

remove_zone - Removes a zone from the district of the planet
	remove_zone = {
		district = <district_type_key/district_slot_index>
		zone = <zone_type_key>
		zone_slot = <zone_slot_index>
		all = <yes/no>
	}
Supported Scopes: planet

kill_assigned_pop_amount - Instantly destroys part of the assigned pops to this job
kill_assigned_pop_amount = {
	limit = { <triggers> }
	amount = <amount killed> OR percentage = <percentage killed>
	random = <number> (optional)
}
Supported Scopes: pop job

merge_species - Triggers the merge of similar sub-species for a country.
integrate_species = yes 
Supported Scopes: country

unlock_council_selection - Unlocks council selection
unlock_council_selection = yes
Supported Scopes: country

validate_planet_buildings_and_districts - Checks whether the planets and districts on the planet are valid (their potential triggers are fulfilled), removes or replaces them if not.
validate_planet_buildings_and_districts = yes
Supported Scopes: planet

add_deposit_category_effect - Adds random non-blocker resource deposit to the scoped planet of a certain category
add_deposit_category_effect = <category>
Supported Scopes: planet

stop_terraform_process - Stops terraforming process of scoped planet
Supported Scopes: planet

reset_event_chain_counter - Resets n event chain counter for the scoped country
reset_event_chain_counter = { event_chain = <key> counter = <key> }
Supported Scopes: country

add_council_agenda_progress - Instantly adds council agenda progress
add_council_agenda_progress = 5
Supported Scopes: country

add_council_agenda_progress_percent - Gives percentage progress (-1.0-1.0) in the current agenda to the scoped country
add_council_agenda_progress_percent = <float>/<variable>
Supported Scopes: country

unlock_council_slots - Unlocks council slots
unlock_council_slots = 1
Supported Scopes: country

set_council_agenda - Set the Country's council agenda 
set_council_agenda = agenda_lets_be_friends
Supported Scopes: country

country_event - Fires a country event for the scoped country, with optional DAYS and RANDOM delay
country_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: country

planet_event - Fires a planet event for the scoped planet, with optional DAYS and RANDOM delay
planet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: planet

random - All enclosed effects may or may not be executed depending on set chance
random = { chance = 50 <effects> }
Supported Scopes: all

create_ship_design - Creates a new ship design for use with last_created_design target
create_ship_design = { design = <key> ftl = <target, optional, sets FTL drive to target country's> }
Supported Scopes: all

change_government - Change the scoped country's government authority and/or civics
change_government = random
or
change_government = {
	authority = random / <key>
	civics = random / { civic = <key> civic = random }
cooldown = no (default: yes)
remove_invalid_civics = yes (default: no)
}
Supported Scopes: country

ship_event - Fires a ship event for the scoped ship, with optional DAYS and RANDOM delay
ship_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: ship

pop_event - Fires a pop event for the scoped pop, with optional DAYS and RANDOM delay
pop_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop

pop_group_event - Fires a pop group event for the scoped pop group, with optional DAYS and RANDOM delay
pop_group_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop_group

enable_special_project - Enables a specific special research project for target country at a specific location (should be same as the current scope where possible)
enable_special_project = { name = <project key> owner = <target, default = root> location = <target, ideally THIS (that is default)> }
Supported Scopes: all

add_resource - Adds specific resource to the stockpile for the country scope:
add_resource = {
	<resource_name_1> = <value_1>
	<resource_name_2> = <value_2>
	...
	mult = <variable> (optional: multiplies all gained resources by a variable)
}
Supported Scopes: country

add_variable - Increments a previously-set variable by a specific amount
add_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

fleet_event - Fires a fleet event for the scoped fleet, with optional DAYS and RANDOM delay
fleet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: fleet

pop_remove_ethic - Removes a specific ethic from the scoped pop
pop_remove_ethic = {
	ethic = <key>
	amount = <amount> OR percentage = <percentage>
	random = <number> (optional) If set, the amount will be randomized in [max(0, size - random), size + random].
}
Supported Scopes: pop_group

set_faction_extorted - Sets the scope faction as extorted and removes extortion from any other ones
set_faction_extorted = <yes|no>
Supported Scopes: pop_faction

create_rebels - Creates a rebellion
create_rebels = {
	name = <random / string>
	authority = <random / key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	ethos = <random / { ethic = <key> ethic = <key> }
}
Supported Scopes: planet

cancel_terraformation - Cancels terraformation of the scoped planet
cancel_terraformation = yes
Supported Scopes: planet

while - Repeats enclosed effects while limit criteria are met or until set iteration count is reached
while = { limit = { <triggers> } <effects> }
 while = { count = [3|Variable] <effects> }
Supported Scopes: all

clear_blocker - Clears scoped deposit blocker and fires its on_cleared effect
clear_blocker = yes
Supported Scopes: deposit

remove_ship_design - Removes a specific ship design from the scoped country
remove_ship_design = <target/last_created_design>
Supported Scopes: country

remove_global_ship_design - Removes a specific global design from the game
remove_global_ship_design = <target>
Supported Scopes: all

every_system_in_cluster - Executes enclosed effects on every system in the cluster that meet the limit criteria
every_system_in_cluster = { limit = { <triggers> } <effects> }
Supported Scopes: all

create_cluster - Creates a cluster centered around the specified spatial object
create_cluster = {
	id = <some_id>
	center = <system, spatial object>
	radius = 30
}
Supported Scopes: all

remove_army - Removes the scoped army
remove_army = yes
Supported Scopes: army

prevent_anomaly - Disables or enables anomaly generation for the scoped planet
prevent_anomaly = yes
Supported Scopes: planet

add_deposit - Adds resource deposit to the scoped object (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
add_deposit = <key/random/random_blocker/random_nonblocker>
Supported Scopes: planet astral_rift

clear_deposits - Removes all deposits from the scoped planet
clear_deposits = yes
Supported Scopes: planet

set_country_type - Changes the country type of the scoped country
set_country_type = <key>
Supported Scopes: country

set_age - Sets the age of the scoped leader
set_age = <int>
Supported Scopes: leader

add_age - Adds the age of the scoped leader
add_age = <int>
Supported Scopes: leader

conquer - Conquers the planet by setting its owner to target country and adding an unhappiness modifier
conquer = <target country>
Supported Scopes: planet

pop_faction_event - Fires a pop faction event for the scoped pop faction, with optional DAYS and RANDOM delay
pop_faction_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop_faction

set_pop_faction_flag - Sets an arbitrarily-named flag on the scoped pop group's faction/pop faction
set_pop_faction_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop pop_group pop_faction

remove_pop_faction_flag - Removes a flag from the scoped pop group's faction/pop faction
remove_pop_faction_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop pop_group pop_faction

set_timed_pop_faction_flag - Sets an arbitrarily-named flag on the scoped pop faction for a set duration
set_timed_pop_faction_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days = <int>
}
Supported Scopes: pop pop_group pop_faction

add_tech_progress - Gives percentage progress (0.0-1.0) in a specific tech to the scoped country
add_tech_progress = { tech = <key> progress = <float>/<variable> }
Supported Scopes: country

set_ruler_title_male - Sets the scoped country's male ruler's title.
set_ruler_title_male = RULER_TITLE_MALE
Supported Scopes: country

set_ruler_title_female - Sets the scoped country's female ruler's title.
set_ruler_title_female = RULER_TITLE_FEMALE
Supported Scopes: country

set_council_position_title_male - Sets the scoped country's council position's male title.
set_council_position_title_male = { position_tag = COUNCIL_POSITION_TAG title = TITLE_MALE }
Supported Scopes: country

set_council_position_title_female - Sets the scoped country's council position's female title.
set_council_position_title_female = { position_tag = COUNCIL_POSITION_TAG title = TITLE_FEMALE }
Supported Scopes: country

repair_building - Repairs a single instance of a specific building on the scoped planet
	repair_building = <building_type_key>
Supported Scopes: planet

abort_special_project - Aborts a specific special project for the country, removing it from the situation log
abort_special_project = { type = <project key> location = <target> }
Supported Scopes: country

observer_event - Fires an observer event for all observers.
Supported Scopes: all

set_custom_capital_location - Sets a custom spatial object as custom country capital location.
set_custom_capital_location = <target>
Supported Scopes: country

spawn_planet - Spawns a planet in a system.
Supported Scopes: galactic_object

spawn_megastructure - Spawns a mega structure in a system.
spawn_megastructure = {
	type = ring_world_ruined
	name = <string>
	owner = <target>
	planet = <planet/star target>
	coords_from = <target> (use this or 'planet' to set the location)
	graphical_culture = <target>
	orbit_distance = 50
	orbit_angle = 50
}
Supported Scopes: galactic_object

remove_megastructure - Removes a mega structure.
remove_megastructure = <target mega structure>
Supported Scopes: all

set_planet_purge_type - Sets the purge type for the entire planet
set_planet_purge_type = <type>
Supported Scopes: planet

trigger_megastructure_icon - if a planet has trigger_megastructure_icon = yes then the map icon for the star will show a megastructure icon
Supported Scopes: planet

run_ai_strategic_data - Recomputes ALL strategic data for AI = yes
Supported Scopes: country

get_trade_data - Passes special trade offer data from the target enclave country to the scoped country.
Only works inside certain parts of the script marked as ai_trade_facility.
get_trade_data = { target = <target> }
Supported Scopes: country

make_special_trade - Makes special trade deal between the target enclave country and the scoped country.
Only works inside certain parts of the script marked as ai_trade_facility.
make_special_trade = { target = <target> }
Supported Scopes: country

add_static_war_exhaustion - Adds static war exhaustion, scaled with value_for_planet_destruction, to owner of the battle location 
add_static_war_exhaustion = {
	attacker = <country>
	location = <planet> 
	value_for_planet_destruction = <0.0-1.0>/<variable> #scales the amount of war exhaustion that is added
}
Supported Scopes: country

set_planet_size - Sets the planet size to a specified number
set_planet_size = <int>
Supported Scopes: planet

add_skill_without_trait_selection - Adds to the scoped leader's skill level but does not select any traits
add_skill_without_trait_selection = 2
Supported Scopes: leader

run_ai_strategic_war_data - Recomputes strategic war ( attack / defense ) data for AI = yes
Supported Scopes: country

expire_site_event - Manually flags an archaeological event as expired
expire_site_event = ancrel.7003
Supported Scopes: archaeological_site

pass_resolution - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type.
pass_resolution = <resolution type>
Supported Scopes: country

pass_resolution_no_cooldown - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type. Skips the cooldown on the relevant category.
pass_resolution_no_cooldown = <resolution type>
Supported Scopes: country

first_contact_event - Fires a first contact event for the scoped first contact site, with optional DAYS and RANDOM delay
first_contact_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: first_contact

finish_first_contact - Ends the First Contact
finish_first_contact = yes
Supported Scopes: first_contact

set_galactic_custodian - Sets whether or not the scoped country is the Galactic Custodian
set_galactic_custodian = yes/no
Supported Scopes: country

set_galactic_emperor - Sets whether or not the scoped country is the Galactic Emperor
set_galactic_emperor = yes/no
Supported Scopes: country

add_imperial_authority - Add imperial_authority
add_imperial_authority = <value>
Supported Scopes: all

add_stage_modifier - Adds a specific modifier to the target's current stage for a set duration or until stage is changed
add_stage_modifier = { modifier = <key> days = <int>, -1 means it never expires> }
Supported Scopes: espionage_operation astral_rift

remove_stage_modifier - Removes a specific modifier from the target current stage
remove_stage_modifier = <key>
Supported Scopes: espionage_operation astral_rift

add_intel_report - Adds the intel level for the category selected. Default duration (0) is forever.
add_intel_report = { category = <string> level = <int> days = <int> who = <target> }
Supported Scopes: country

set_galactic_defense_force - Sets whether the Galactic Defense force or Imperial Armada exists
set_galactic_defense_force = yes/no
Supported Scopes: all

clear_intel_report - Removes all the intel reports related to the provided category.
clear_intel_report = { category = <string> who = <target> }
Supported Scopes: country

starbase_event - Fires a starbase event for the scoped starbase
starbase_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: starbase

system_event - Fires a system event for the scoped system
system_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: galactic_object

leader_event - Fires a leader event for the scoped leader
leader_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: leader

situation_event - Fires a situation event for the scoped situation
situation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: situation

agreement_event - Fires an agreement event for the scoped agreement
agreement_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: agreement

transfer_galactic_defense_force_fleets - Moves all owned GDF fleets to the target.
transfer_galactic_defense_force_fleets = <target>
Supported Scopes: country

cancel_resolution - Immediately cancels/removes the latest active/passed/proposed/voting for/failed resolution of this type
cancel_resolution = <resolution type>
Supported Scopes: country

add_spy_network_level - Adds levels to the current Spy Network
add_spy_network_level = <int>
Supported Scopes: spy_network

join_alliance - Join federation with target
join_alliance = { who = <target> override_requirements = yes/no }
Supported Scopes: country

complete_tutorial_step - Create and sends an telemetry event keeping track of the tutorial steps for the current game
Supported Scopes: all

set_emperor_can_change_council_members - Sets whether the Galactic Emperor can change Imperial Council members or not
set_emperor_can_change_council_members = yes/no
Supported Scopes: all

give_fleet - Leases fleet out to the new controller country for a numbed of days 
give_fleet = {
	controller = <target country> 
	days = <number of days>
}
Supported Scopes: fleet

prolong_fleet_contract - Prolongs fleet's lease contract for a numbed of days 
prolong_fleet_contract = { days = <number of days> }
Supported Scopes: fleet

set_fleet_settings - Set fleet's settings, any unspecified setting will set to default value.
set_fleet_settings = { can_upgrade = no can_change_leader = no ... }
Supported Scopes: fleet

astral_rift_event - Fires an astral rift event with optional DAYS and RANDOM 
delay
astral_rift_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: astral_rift

fill_astral_rift_event_pool - Fills the astral rift event pool for every playable country.
Supported Scopes: country

bypass_event - Fires a bypass event for the scoped bypass, with optional DAYS and RANDOM delay
bypass_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: bypass

finish_astral_rift - Ends the Astral Rift exploration
finish_astral_rift = yes
Supported Scopes: astral_rift

set_next_astral_rift_event - Sets next Astral Rift event through an astral rift event ID, and another astral rift event ID to be called in case of a roll failed, alongside a trigger probability.	To fire an Astral Rift event immediately, use astral_rift_event instead.
set_next_astral_rift_event = {
	id = <event_id>
	on_roll_failed = <event_id> (optional: specify astral rift event set when a roll fails)
	fail_probability = <float> (optional: specify astral rift event probability to trigger on a failed roll)
}
Supported Scopes: astral_rift

unlock_exhibit - Unlocks an exhibit for given category from the target country.
unlock_exhibit = <category>
Supported Scopes: country

enable_mission - Enables a mission for target country
 enable_mission = { name = <mission key> }
Supported Scopes: all

refresh_leader_pool - Refreshes the scoped country's leader pool.
refresh_leader_pool = yes
Supported Scopes: country

add_resource_from_debris - Adds specific resource to the stockpile for the country scope and creates a debris notification:
add_resource = {
	<resource_name_1> = <value_1>
	<resource_name_2> = <value_2>
	...
	system = <system>
	mult = <variable> (optional: multiplies all gained resources by a variable)
}
Supported Scopes: country

add_terraformation_total_time_mult - Adds a percentage to the total time of the current terraforminog process on the planet
terraformation_total_time_mult = <value>
Supported Scopes: planet

add_timeline_event - Adds a new timeline event for the scope country.
add_timeline_event = {
  type = timeline_event_planet
  date = 2300.1.1 (optional - if not present, current date is used)
  targets = { ... } (optional - array of event targets. This depends on localization and what event targets the type requires)

  (There is also overrides that can be used to override settings on the database entries. The Id is required, and the others are optional)
  override_id = my_defined_unique_id
  override_text = { "button:MY_OTHER_LOC_STRING" "button2:ANOTHER_LOC_OVERRIDE" }  override_texture = { "button:GFX_short_button button2:GFX_otherbutton" }  override_tooltip, "loc_tooltip"  override_tooltip_delayed, "loc_delayed_tooltip"}
Supported Scopes: country

propose_resolution - Proposes the resolution of the given type
ppropose_resolution = {
	resolution = <resolution type>
	target = <event_target:country> (optional)}
Supported Scopes: country

weighted_random_owned_pop_group - Weighted random on owned popgroups based on the popgroup size. Supports the same scopes as the owned_pop_group script list
Supported Scopes: planet country pop_faction sector

set_trade_conversions - Sets the trade conversions for the scoped Country. If they do not add up to 1.0 any remaining trade the country keeps as income
set_trade_conversion = { energy = 0.5 minerals = 0.2 }
Supported Scopes: country

refresh_auto_generated_ship_designs - Refresh ship designs that are aut-generated such as colony ships
refresh_auto_generated_ship_designs = yes
Supported Scopes: country

set_resource - Sets the specific resource to the stockpile for the country scope:
set_resource = {
	resource = <resource_name>
	value = <variable>
}
Supported Scopes: country

create_leader - Creates a new leader for the scoped country
create_leader = {
	name = random / <string>
	species = last_created / <target>
	class = random_ruler / <key>
	skill = <int> # The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
	set_age = <int>
	traits = { <level> = <key> <level> = <key> } # The traits of the leader, e.g. "1 = leader_trait_bureaucrat". If <level> is a positive int and randomize_traits = yes, the trait is added if the leader's level is at least <level>.
	gender = <gender> # Optional, default = random.
	event_leader = yes / no # Optional, default = no. Sets if this is a event leader or not. Is checked through is_event_leader.
	immortal = yes / no # Optional, default = no.
	hide_age = yes / no # Optional, default = no.
	sub_type = <key> # Optional. Used for scientist subtypes.
	can_manually_change_location = yes / no # Optional, default = yes.
	can_assign_to_council = yes/no # Optional, default = yes.
	hide_leader = yes / no # Optional, default = no. Hides the leader from the player's list of leaders, and doesn't count them towards the leader cap.
	randomize_traits = yes / no # Optional, default = yes. Does not randomize for levels that are specified in traits.
	leader_age_min = <int> # Optional, but requires leader_age_max if used. Used to randomize leader age within the age span between this and leader_age_max.
	leader_age_max = <int> # Optional, but requires leader_age_min if used. Used to randomize leader age within the age span between this and leader_age_min.
	use_regnal_name = yes/no # Optional, default = no. If generating a random name, use regnal names if the name list has them.	effect = { <effect> } # Optional. Scripted effect(s) that are run on the leader after it has been created.

	custom_description = <key> # Optional.
	custom_catch_phrase = <string> # Optional.
	skip_background_generation = yes / no # Optional, default = no. Disables random generation of a background.
	background_planet = <target> # Optional. Used as the home planet of the leader.
	background_job = <key> # Optional.
	background_ethic = <key> # Optional.
}
Supported Scopes: country

set_disabled - Enables or disables the scoped ship
set_disabled = no
Supported Scopes: ship

else - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
if = { limit = { <triggers> } <effects> }
else = { <effects> }
Supported Scopes: all

log - Prints a message to game.log for debugging purposes.
Supported Scopes: all

debug_break - Trigger an assertion to stop the debugger when encountering this effect; argument is ignored
debug_break = yes
Supported Scopes: all

inverted_switch - Executes the first appropriate effect set for a specific trigger treated as NOT.
inverted_switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}
Supported Scopes: all

random_agreement - Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_agreement = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope

ordered_agreement - Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_agreement = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope

every_agreement - Iterate through each agreement - executes the enclosed effects on all of them for which the limit triggers return true
every_agreement = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope

random_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ambient_object = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ambient_object = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on all of them for which the limit triggers return true
every_ambient_object = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_ambient_object = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_ambient_object = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_ambient_object = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_archaeological_site = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_archaeological_site = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on all of them for which the limit triggers return true
every_archaeological_site = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_army = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_army = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_army = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_planet_army = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_planet_army = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on all of them for which the limit triggers return true
every_planet_army = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ground_combat_defender = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ground_combat_defender = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
every_ground_combat_defender = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ground_combat_attacker = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ground_combat_attacker = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
every_ground_combat_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_astral_rift - Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_astral_rift = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_astral_rift - Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_astral_rift = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_astral_rift - Iterate through every astral rift - executes the enclosed effects on all of them for which the limit triggers return true
every_astral_rift = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_bypass - Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_bypass = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_bypass - Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_bypass = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_bypass - Iterate through every bypass - executes the enclosed effects on all of them for which the limit triggers return true
every_bypass = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_bypass_in_system - Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_bypass_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_bypass_in_system - Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_bypass_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_bypass_in_system - Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on all of them for which the limit triggers return true
every_bypass_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_within_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_within_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_within_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm_start_position = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm_start_position = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm_start_position = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm_end_position = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm_end_position = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm_end_position = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_added_to_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_added_to_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_added_to_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_removed_from_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_removed_from_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_removed_from_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_storm_influence_field = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_storm_influence_field = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_storm_influence_field = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_in_cosmic_storm_influence_field = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm_influence_field

ordered_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_in_cosmic_storm_influence_field = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm_influence_field

every_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
every_system_in_cosmic_storm_influence_field = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm_influence_field

random_country - Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_country - Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_country - Iterate through all countries - executes the enclosed effects on all of them for which the limit triggers return true
every_country = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_relation - Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_relation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_relation - Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_relation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_relation - Iterate through all relations - executes the enclosed effects on all of them for which the limit triggers return true
every_relation = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_country = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_country_neighbor_to_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_country_neighbor_to_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on all of them for which the limit triggers return true
every_country_neighbor_to_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_rival_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_rival_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_rival_country = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_federation_ally = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_federation_ally = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_federation_ally = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_playable_country - Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_playable_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_playable_country - Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_playable_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_playable_country - Iterate through all playable countries - executes the enclosed effects on all of them for which the limit triggers return true
every_playable_country = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_subject = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_subject = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_subject = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_available_debris = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_available_debris = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_available_debris = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pre_ftl_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pre_ftl_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_pre_ftl_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_observed_pre_ftl_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_observed_pre_ftl_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_observed_pre_ftl_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_design = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_design = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_design = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_spynetwork - Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_spynetwork = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope

ordered_spynetwork - Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_spynetwork = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope

every_spynetwork - Iterate through each spynetwork - executes the enclosed effects on all of them for which the limit triggers return true
every_spynetwork = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope

random_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_espionage_operation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope spy_network

ordered_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_espionage_operation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope spy_network

every_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on all of them for which the limit triggers return true
every_espionage_operation = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope spy_network

random_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_espionage_asset = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: no_scope spy_network espionage_operation

ordered_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_espionage_asset = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: no_scope spy_network espionage_operation

every_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on all of them for which the limit triggers return true
every_espionage_asset = { limit = { <triggers> } <effects> }
Supported Scopes: no_scope spy_network espionage_operation

random_exhibit - Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_exhibit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_exhibit - Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_exhibit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_exhibit - Iterate through every exhibit - executes the enclosed effects on all of them for which the limit triggers return true
every_exhibit = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_federation - Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_federation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_federation - Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_federation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_federation - Iterate through each federation - executes the enclosed effects on all of them for which the limit triggers return true
every_federation = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_first_contact = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_first_contact = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
every_first_contact = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_active_first_contact = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_active_first_contact = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
every_active_first_contact = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_combatant_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: fleet

ordered_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_combatant_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: fleet

every_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on all of them for which the limit triggers return true
every_combatant_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: fleet

random_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_fleet_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_fleet_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_fleet_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_fleet_in_orbit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: megastructure planet starbase

ordered_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_fleet_in_orbit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: megastructure planet starbase

every_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_fleet_in_orbit = { limit = { <triggers> } <effects> }
Supported Scopes: megastructure planet starbase

random_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_orbital_station = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country galactic_object

ordered_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_orbital_station = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country galactic_object

every_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_orbital_station = { limit = { <triggers> } <effects> }
Supported Scopes: country galactic_object

random_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galcom_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galcom_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on all of them for which the limit triggers return true
every_galcom_member = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_council_member - Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_council_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_council_member - Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_council_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_council_member - Iterate through each member of the galactic council - executes the enclosed effects on all of them for which the limit triggers return true
every_council_member = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_leader = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_leader = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_leader = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pool_leader = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pool_leader = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on all of them for which the limit triggers return true
every_pool_leader = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_envoy - Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_envoy = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_envoy - Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_envoy = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_envoy - Iterate through each envoy available to the country - executes the enclosed effects on all of them for which the limit triggers return true
every_envoy = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_megastructure - Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_megastructure - Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_megastructure - Iterate through each megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_member - Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: federation

ordered_member - Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: federation

every_member - Iterate through each member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
every_member = { limit = { <triggers> } <effects> }
Supported Scopes: federation

random_associate - Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_associate = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: federation

ordered_associate - Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_associate = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: federation

every_associate - Iterate through each associate member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
every_associate = { limit = { <triggers> } <effects> }
Supported Scopes: federation

random_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_planet = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_system_colony - Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_colony = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_colony - Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_colony = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_colony - Iterate through each colony in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_colony = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_planet_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_planet_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_planet_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_planet = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_planet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_planet = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_deposit - Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_deposit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_deposit - Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_deposit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_deposit - Iterate through each deposit on the planet - executes the enclosed effects on all of them for which the limit triggers return true
every_deposit = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_moon - Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_moon = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_moon - Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_moon = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_moon - Iterate through each moon of the planet - executes the enclosed effects on all of them for which the limit triggers return true
every_moon = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pop_faction = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pop_faction = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on all of them for which the limit triggers return true
every_pop_faction = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_group = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country pop_faction sector

ordered_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_group = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country pop_faction sector

every_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_group = { limit = { <triggers> } <effects> }
Supported Scopes: planet country pop_faction sector

random_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_species_pop_group = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: species

ordered_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_species_pop_group = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: species

every_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on all of them for which the limit triggers return true
every_species_pop_group = { limit = { <triggers> } <effects> }
Supported Scopes: species

random_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_job = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country sector

ordered_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_job = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country sector

every_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_job = { limit = { <triggers> } <effects> }
Supported Scopes: planet country sector

random_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_sector = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_sector = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_sector = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_sector - Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_sector = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_sector - Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_sector = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_sector - Iterate through every owned sector - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_sector = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_ship = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country fleet

ordered_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_ship = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country fleet

every_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_ship = { limit = { <triggers> } <effects> }
Supported Scopes: country fleet

random_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_ship = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country fleet

ordered_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_ship = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country fleet

every_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_ship = { limit = { <triggers> } <effects> }
Supported Scopes: country fleet

random_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ship_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ship_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_ship_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_situation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_situation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on all of them for which the limit triggers return true
every_situation = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_targeting_situation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_targeting_situation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on all of them for which the limit triggers return true
every_targeting_situation = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_species = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_species = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country

ordered_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country

every_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_species = { limit = { <triggers> } <effects> }
Supported Scopes: planet country

random_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_enslaved_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country

ordered_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_enslaved_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country

every_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_enslaved_species = { limit = { <triggers> } <effects> }
Supported Scopes: planet country

random_existing_species_traits - Iterate through all existing species traits in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_existing_species_traits = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: no_scope

ordered_existing_species_traits - Iterate through all existing species traits in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_existing_species_traits = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: no_scope

every_existing_species_traits - Iterate through all existing species traits in the game - executes the enclosed effects on all of them for which the limit triggers return true
every_existing_species_traits = { limit = { <triggers> } <effects> }
Supported Scopes: no_scope

random_trait_of_species - Iterate through each trait that the scoped species has
trait_of_species = { trait_has_all_tags = { positive } } - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_trait_of_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: pop pop_group leader species

ordered_trait_of_species - Iterate through each trait that the scoped species has
trait_of_species = { trait_has_all_tags = { positive } } - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_trait_of_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: pop pop_group leader species

every_trait_of_species - Iterate through each trait that the scoped species has
trait_of_species = { trait_has_all_tags = { positive } } - executes the enclosed effects on all of them for which the limit triggers return true
every_trait_of_species = { limit = { <triggers> } <effects> }
Supported Scopes: pop pop_group leader species

random_trait_available_for_species - Iterate through all species traits and check if scope species doesn't have this trait
traits_available_for_species = { trait_has_all_tags = { organic positive } } - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_trait_available_for_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: pop pop_group leader species

ordered_trait_available_for_species - Iterate through all species traits and check if scope species doesn't have this trait
traits_available_for_species = { trait_has_all_tags = { organic positive } } - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_trait_available_for_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: pop pop_group leader species

every_trait_available_for_species - Iterate through all species traits and check if scope species doesn't have this trait
traits_available_for_species = { trait_has_all_tags = { organic positive } } - executes the enclosed effects on all of them for which the limit triggers return true
every_trait_available_for_species = { limit = { <triggers> } <effects> }
Supported Scopes: pop pop_group leader species

random_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_starbase = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_starbase = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_starbase = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_nonprimary_starbase = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_nonprimary_starbase = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_nonprimary_starbase = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_starbase_in_system - Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_starbase_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_starbase_in_system - Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_starbase_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_starbase_in_system - Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on all of them for which the limit triggers return true
every_starbase_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_system - Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_system - Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_system - Iterate through all systems - executes the enclosed effects on all of them for which the limit triggers return true
every_system = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_rim_system - Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_rim_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_rim_system - Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_rim_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_rim_system - Iterate through all rim systems - executes the enclosed effects on all of them for which the limit triggers return true
every_rim_system = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_system_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_system_euclidean = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_system_euclidean = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_system_euclidean = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_war_participant - Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_war_participant = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_war_participant - Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_war_participant = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_war_participant - Iterate through all war participants - executes the enclosed effects on all of them for which the limit triggers return true
every_war_participant = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_attacker - Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_attacker = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_attacker - Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_attacker = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_attacker - Iterate through all attackers in the current war - executes the enclosed effects on all of them for which the limit triggers return true
every_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_defender - Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_defender = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_defender - Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_defender = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_defender - Iterate through all defenders in the current war - executes the enclosed effects on all of them for which the limit triggers return true
every_defender = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_war - Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_war = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_war - Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_war = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_war - Iterate through all wars the country is engaged in - executes the enclosed effects on all of them for which the limit triggers return true
every_war = { limit = { <triggers> } <effects> }
Supported Scopes: country


=================
